(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const s of document.querySelectorAll('link[rel="modulepreload"]')) r(s); new MutationObserver(s => { for (const i of s) if (i.type === "childList") for (const a of i.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && r(a) }).observe(document, { childList: !0, subtree: !0 }); function t(s) { const i = {}; return s.integrity && (i.integrity = s.integrity), s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function r(s) { if (s.ep) return; s.ep = !0; const i = t(s); fetch(s.href, i) } })(); var mn = {}, pe = {}, L = {}; Object.defineProperty(L, "__esModule", { value: !0 }); class ae extends Error { } class Dr extends ae { constructor(e) { super(`Invalid DateTime: ${e.toMessage()}`) } } class Er extends ae { constructor(e) { super(`Invalid Interval: ${e.toMessage()}`) } } class Mr extends ae { constructor(e) { super(`Invalid Duration: ${e.toMessage()}`) } } class ye extends ae { } class yn extends ae { constructor(e) { super(`Invalid unit ${e}`) } } class V extends ae { } class j extends ae { constructor() { super("Zone is an abstract class") } } const f = "numeric", P = "short", _ = "long", Ge = { year: f, month: f, day: f }, gn = { year: f, month: P, day: f }, Nr = { year: f, month: P, day: f, weekday: P }, wn = { year: f, month: _, day: f }, kn = { year: f, month: _, day: f, weekday: _ }, pn = { hour: f, minute: f }, Sn = { hour: f, minute: f, second: f }, Tn = { hour: f, minute: f, second: f, timeZoneName: P }, On = { hour: f, minute: f, second: f, timeZoneName: _ }, In = { hour: f, minute: f, hourCycle: "h23" }, vn = { hour: f, minute: f, second: f, hourCycle: "h23" }, Dn = { hour: f, minute: f, second: f, hourCycle: "h23", timeZoneName: P }, En = { hour: f, minute: f, second: f, hourCycle: "h23", timeZoneName: _ }, Mn = { year: f, month: f, day: f, hour: f, minute: f }, Nn = { year: f, month: f, day: f, hour: f, minute: f, second: f }, Fn = { year: f, month: P, day: f, hour: f, minute: f }, bn = { year: f, month: P, day: f, hour: f, minute: f, second: f }, Fr = { year: f, month: P, day: f, weekday: P, hour: f, minute: f }, xn = { year: f, month: _, day: f, hour: f, minute: f, timeZoneName: P }, Vn = { year: f, month: _, day: f, hour: f, minute: f, second: f, timeZoneName: P }, Wn = { year: f, month: _, day: f, weekday: _, hour: f, minute: f, timeZoneName: _ }, Cn = { year: f, month: _, day: f, weekday: _, hour: f, minute: f, second: f, timeZoneName: _ }; class Te { get type() { throw new j } get name() { throw new j } get ianaName() { return this.name } get isUniversal() { throw new j } offsetName(e, t) { throw new j } formatOffset(e, t) { throw new j } offset(e) { throw new j } equals(e) { throw new j } get isValid() { throw new j } } let ot = null; class Ve extends Te { static get instance() { return ot === null && (ot = new Ve), ot } get type() { return "system" } get name() { return new Intl.DateTimeFormat().resolvedOptions().timeZone } get isUniversal() { return !1 } offsetName(e, { format: t, locale: r }) { return Hn(e, t, r) } formatOffset(e, t) { return be(this.offset(e), t) } offset(e) { return -new Date(e).getTimezoneOffset() } equals(e) { return e.type === "system" } get isValid() { return !0 } } let qe = {}; function br(n) { return qe[n] || (qe[n] = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: n, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", era: "short" })), qe[n] } const xr = { year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6 }; function Vr(n, e) { const t = n.format(e).replace(/\u200E/g, ""), r = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(t), [, s, i, a, o, u, l, h] = r; return [a, s, i, o, u, l, h] } function Wr(n, e) { const t = n.formatToParts(e), r = []; for (let s = 0; s < t.length; s++) { const { type: i, value: a } = t[s], o = xr[i]; i === "era" ? r[o] = a : k(o) || (r[o] = parseInt(a, 10)) } return r } let Ae = {}; class G extends Te { static create(e) { return Ae[e] || (Ae[e] = new G(e)), Ae[e] } static resetCache() { Ae = {}, qe = {} } static isValidSpecifier(e) { return this.isValidZone(e) } static isValidZone(e) { if (!e) return !1; try { return new Intl.DateTimeFormat("en-US", { timeZone: e }).format(), !0 } catch { return !1 } } constructor(e) { super(), this.zoneName = e, this.valid = G.isValidZone(e) } get type() { return "iana" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName(e, { format: t, locale: r }) { return Hn(e, t, r, this.name) } formatOffset(e, t) { return be(this.offset(e), t) } offset(e) { const t = new Date(e); if (isNaN(t)) return NaN; const r = br(this.name); let [s, i, a, o, u, l, h] = r.formatToParts ? Wr(r, t) : Vr(r, t); o === "BC" && (s = -Math.abs(s) + 1); const E = Xe({ year: s, month: i, day: a, hour: u === 24 ? 0 : u, minute: l, second: h, millisecond: 0 }); let g = +t; const O = g % 1e3; return g -= O >= 0 ? O : 1e3 + O, (E - g) / (60 * 1e3) } equals(e) { return e.type === "iana" && e.name === this.name } get isValid() { return this.valid } } let _t = {}; function Cr(n, e = {}) { const t = JSON.stringify([n, e]); let r = _t[t]; return r || (r = new Intl.ListFormat(n, e), _t[t] = r), r } let gt = {}; function wt(n, e = {}) { const t = JSON.stringify([n, e]); let r = gt[t]; return r || (r = new Intl.DateTimeFormat(n, e), gt[t] = r), r } let kt = {}; function $r(n, e = {}) { const t = JSON.stringify([n, e]); let r = kt[t]; return r || (r = new Intl.NumberFormat(n, e), kt[t] = r), r } let pt = {}; function _r(n, e = {}) { const { base: t, ...r } = e, s = JSON.stringify([n, r]); let i = pt[s]; return i || (i = new Intl.RelativeTimeFormat(n, e), pt[s] = i), i } let Me = null; function Lr() { return Me || (Me = new Intl.DateTimeFormat().resolvedOptions().locale, Me) } let Lt = {}; function Ar(n) { let e = Lt[n]; if (!e) { const t = new Intl.Locale(n); e = "getWeekInfo" in t ? t.getWeekInfo() : t.weekInfo, Lt[n] = e } return e } function Zr(n) { const e = n.indexOf("-x-"); e !== -1 && (n = n.substring(0, e)); const t = n.indexOf("-u-"); if (t === -1) return [n]; { let r, s; try { r = wt(n).resolvedOptions(), s = n } catch { const u = n.substring(0, t); r = wt(u).resolvedOptions(), s = u } const { numberingSystem: i, calendar: a } = r; return [s, i, a] } } function Rr(n, e, t) { return (t || e) && (n.includes("-u-") || (n += "-u"), t && (n += `-ca-${t}`), e && (n += `-nu-${e}`)), n } function zr(n) { const e = []; for (let t = 1; t <= 12; t++) { const r = w.utc(2009, t, 1); e.push(n(r)) } return e } function Ur(n) { const e = []; for (let t = 1; t <= 7; t++) { const r = w.utc(2016, 11, 13 + t); e.push(n(r)) } return e } function Ze(n, e, t, r) { const s = n.listingMode(); return s === "error" ? null : s === "en" ? t(e) : r(e) } function qr(n) { return n.numberingSystem && n.numberingSystem !== "latn" ? !1 : n.numberingSystem === "latn" || !n.locale || n.locale.startsWith("en") || new Intl.DateTimeFormat(n.intl).resolvedOptions().numberingSystem === "latn" } class Hr { constructor(e, t, r) { this.padTo = r.padTo || 0, this.floor = r.floor || !1; const { padTo: s, floor: i, ...a } = r; if (!t || Object.keys(a).length > 0) { const o = { useGrouping: !1, ...r }; r.padTo > 0 && (o.minimumIntegerDigits = r.padTo), this.inf = $r(e, o) } } format(e) { if (this.inf) { const t = this.floor ? Math.floor(e) : e; return this.inf.format(t) } else { const t = this.floor ? Math.floor(e) : Nt(e, 3); return F(t, this.padTo) } } } class Yr { constructor(e, t, r) { this.opts = r, this.originalZone = void 0; let s; if (this.opts.timeZone) this.dt = e; else if (e.zone.type === "fixed") { const a = -1 * (e.offset / 60), o = a >= 0 ? `Etc/GMT+${a}` : `Etc/GMT${a}`; e.offset !== 0 && G.create(o).valid ? (s = o, this.dt = e) : (s = "UTC", this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone) } else e.zone.type === "system" ? this.dt = e : e.zone.type === "iana" ? (this.dt = e, s = e.zone.name) : (s = "UTC", this.dt = e.setZone("UTC").plus({ minutes: e.offset }), this.originalZone = e.zone); const i = { ...this.opts }; i.timeZone = i.timeZone || s, this.dtf = wt(t, i) } format() { return this.originalZone ? this.formatToParts().map(({ value: e }) => e).join("") : this.dtf.format(this.dt.toJSDate()) } formatToParts() { const e = this.dtf.formatToParts(this.dt.toJSDate()); return this.originalZone ? e.map(t => { if (t.type === "timeZoneName") { const r = this.originalZone.offsetName(this.dt.ts, { locale: this.dt.locale, format: this.opts.timeZoneName }); return { ...t, value: r } } else return t }) : e } resolvedOptions() { return this.dtf.resolvedOptions() } } class Pr { constructor(e, t, r) { this.opts = { style: "long", ...r }, !t && Un() && (this.rtf = _r(e, r)) } format(e, t) { return this.rtf ? this.rtf.format(e, t) : ms(t, e, this.opts.numeric, this.opts.style !== "long") } formatToParts(e, t) { return this.rtf ? this.rtf.formatToParts(e, t) : [] } } const Gr = { firstDay: 1, minimalDays: 4, weekend: [6, 7] }; class D { static fromOpts(e) { return D.create(e.locale, e.numberingSystem, e.outputCalendar, e.weekSettings, e.defaultToEN) } static create(e, t, r, s, i = !1) { const a = e || N.defaultLocale, o = a || (i ? "en-US" : Lr()), u = t || N.defaultNumberingSystem, l = r || N.defaultOutputCalendar, h = St(s) || N.defaultWeekSettings; return new D(o, u, l, h, a) } static resetCache() { Me = null, gt = {}, kt = {}, pt = {} } static fromObject({ locale: e, numberingSystem: t, outputCalendar: r, weekSettings: s } = {}) { return D.create(e, t, r, s) } constructor(e, t, r, s, i) { const [a, o, u] = Zr(e); this.locale = a, this.numberingSystem = t || o || null, this.outputCalendar = r || u || null, this.weekSettings = s, this.intl = Rr(this.locale, this.numberingSystem, this.outputCalendar), this.weekdaysCache = { format: {}, standalone: {} }, this.monthsCache = { format: {}, standalone: {} }, this.meridiemCache = null, this.eraCache = {}, this.specifiedLocale = i, this.fastNumbersCached = null } get fastNumbers() { return this.fastNumbersCached == null && (this.fastNumbersCached = qr(this)), this.fastNumbersCached } listingMode() { const e = this.isEnglish(), t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory"); return e && t ? "en" : "intl" } clone(e) { return !e || Object.getOwnPropertyNames(e).length === 0 ? this : D.create(e.locale || this.specifiedLocale, e.numberingSystem || this.numberingSystem, e.outputCalendar || this.outputCalendar, St(e.weekSettings) || this.weekSettings, e.defaultToEN || !1) } redefaultToEN(e = {}) { return this.clone({ ...e, defaultToEN: !0 }) } redefaultToSystem(e = {}) { return this.clone({ ...e, defaultToEN: !1 }) } months(e, t = !1) { return Ze(this, e, Gn, () => { const r = t ? { month: e, day: "numeric" } : { month: e }, s = t ? "format" : "standalone"; return this.monthsCache[s][e] || (this.monthsCache[s][e] = zr(i => this.extract(i, r, "month"))), this.monthsCache[s][e] }) } weekdays(e, t = !1) { return Ze(this, e, jn, () => { const r = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e }, s = t ? "format" : "standalone"; return this.weekdaysCache[s][e] || (this.weekdaysCache[s][e] = Ur(i => this.extract(i, r, "weekday"))), this.weekdaysCache[s][e] }) } meridiems() { return Ze(this, void 0, () => Qn, () => { if (!this.meridiemCache) { const e = { hour: "numeric", hourCycle: "h12" }; this.meridiemCache = [w.utc(2016, 11, 13, 9), w.utc(2016, 11, 13, 19)].map(t => this.extract(t, e, "dayperiod")) } return this.meridiemCache }) } eras(e) { return Ze(this, e, Kn, () => { const t = { era: e }; return this.eraCache[e] || (this.eraCache[e] = [w.utc(-40, 1, 1), w.utc(2017, 1, 1)].map(r => this.extract(r, t, "era"))), this.eraCache[e] }) } extract(e, t, r) { const s = this.dtFormatter(e, t), i = s.formatToParts(), a = i.find(o => o.type.toLowerCase() === r); return a ? a.value : null } numberFormatter(e = {}) { return new Hr(this.intl, e.forceSimple || this.fastNumbers, e) } dtFormatter(e, t = {}) { return new Yr(e, this.intl, t) } relFormatter(e = {}) { return new Pr(this.intl, this.isEnglish(), e) } listFormatter(e = {}) { return Cr(this.intl, e) } isEnglish() { return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us") } getWeekSettings() { return this.weekSettings ? this.weekSettings : qn() ? Ar(this.locale) : Gr } getStartOfWeek() { return this.getWeekSettings().firstDay } getMinDaysInFirstWeek() { return this.getWeekSettings().minimalDays } getWeekendDays() { return this.getWeekSettings().weekend } equals(e) { return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar } toString() { return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})` } } let ut = null; class C extends Te { static get utcInstance() { return ut === null && (ut = new C(0)), ut } static instance(e) { return e === 0 ? C.utcInstance : new C(e) } static parseSpecifier(e) { if (e) { const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i); if (t) return new C(et(t[1], t[2])) } return null } constructor(e) { super(), this.fixed = e } get type() { return "fixed" } get name() { return this.fixed === 0 ? "UTC" : `UTC${be(this.fixed, "narrow")}` } get ianaName() { return this.fixed === 0 ? "Etc/UTC" : `Etc/GMT${be(-this.fixed, "narrow")}` } offsetName() { return this.name } formatOffset(e, t) { return be(this.fixed, t) } get isUniversal() { return !0 } offset() { return this.fixed } equals(e) { return e.type === "fixed" && e.fixed === this.fixed } get isValid() { return !0 } } class $n extends Te { constructor(e) { super(), this.zoneName = e } get type() { return "invalid" } get name() { return this.zoneName } get isUniversal() { return !1 } offsetName() { return null } formatOffset() { return "" } offset() { return NaN } equals() { return !1 } get isValid() { return !1 } } function X(n, e) { if (k(n) || n === null) return e; if (n instanceof Te) return n; if (Xr(n)) { const t = n.toLowerCase(); return t === "default" ? e : t === "local" || t === "system" ? Ve.instance : t === "utc" || t === "gmt" ? C.utcInstance : C.parseSpecifier(t) || G.create(n) } else return ee(n) ? C.instance(n) : typeof n == "object" && "offset" in n && typeof n.offset == "function" ? n : new $n(n) } const vt = { arab: "[٠-٩]", arabext: "[۰-۹]", bali: "[᭐-᭙]", beng: "[০-৯]", deva: "[०-९]", fullwide: "[０-９]", gujr: "[૦-૯]", hanidec: "[〇|一|二|三|四|五|六|七|八|九]", khmr: "[០-៩]", knda: "[೦-೯]", laoo: "[໐-໙]", limb: "[᥆-᥏]", mlym: "[൦-൯]", mong: "[᠐-᠙]", mymr: "[၀-၉]", orya: "[୦-୯]", tamldec: "[௦-௯]", telu: "[౦-౯]", thai: "[๐-๙]", tibt: "[༠-༩]", latn: "\\d" }, At = { arab: [1632, 1641], arabext: [1776, 1785], bali: [6992, 7001], beng: [2534, 2543], deva: [2406, 2415], fullwide: [65296, 65303], gujr: [2790, 2799], khmr: [6112, 6121], knda: [3302, 3311], laoo: [3792, 3801], limb: [6470, 6479], mlym: [3430, 3439], mong: [6160, 6169], mymr: [4160, 4169], orya: [2918, 2927], tamldec: [3046, 3055], telu: [3174, 3183], thai: [3664, 3673], tibt: [3872, 3881] }, Jr = vt.hanidec.replace(/[\[|\]]/g, "").split(""); function Br(n) { let e = parseInt(n, 10); if (isNaN(e)) { e = ""; for (let t = 0; t < n.length; t++) { const r = n.charCodeAt(t); if (n[t].search(vt.hanidec) !== -1) e += Jr.indexOf(n[t]); else for (const s in At) { const [i, a] = At[s]; r >= i && r <= a && (e += r - i) } } return parseInt(e, 10) } else return e } let he = {}; function jr() { he = {} } function q({ numberingSystem: n }, e = "") { const t = n || "latn"; return he[t] || (he[t] = {}), he[t][e] || (he[t][e] = new RegExp(`${vt[t]}${e}`)), he[t][e] } let Zt = () => Date.now(), Rt = "system", zt = null, Ut = null, qt = null, Ht = 60, Yt, Pt = null; class N { static get now() { return Zt } static set now(e) { Zt = e } static set defaultZone(e) { Rt = e } static get defaultZone() { return X(Rt, Ve.instance) } static get defaultLocale() { return zt } static set defaultLocale(e) { zt = e } static get defaultNumberingSystem() { return Ut } static set defaultNumberingSystem(e) { Ut = e } static get defaultOutputCalendar() { return qt } static set defaultOutputCalendar(e) { qt = e } static get defaultWeekSettings() { return Pt } static set defaultWeekSettings(e) { Pt = St(e) } static get twoDigitCutoffYear() { return Ht } static set twoDigitCutoffYear(e) { Ht = e % 100 } static get throwOnInvalid() { return Yt } static set throwOnInvalid(e) { Yt = e } static resetCaches() { D.resetCache(), G.resetCache(), w.resetCache(), jr() } } class Y { constructor(e, t) { this.reason = e, this.explanation = t } toMessage() { return this.explanation ? `${this.reason}: ${this.explanation}` : this.reason } } const _n = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334], Ln = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335]; function z(n, e) { return new Y("unit out of range", `you specified ${e} (of type ${typeof e}) as a ${n}, which is invalid`) } function Dt(n, e, t) { const r = new Date(Date.UTC(n, e - 1, t)); n < 100 && n >= 0 && r.setUTCFullYear(r.getUTCFullYear() - 1900); const s = r.getUTCDay(); return s === 0 ? 7 : s } function An(n, e, t) { return t + (We(n) ? Ln : _n)[e - 1] } function Zn(n, e) { const t = We(n) ? Ln : _n, r = t.findIndex(i => i < e), s = e - t[r]; return { month: r + 1, day: s } } function Et(n, e) { return (n - e + 7) % 7 + 1 } function Je(n, e = 4, t = 1) { const { year: r, month: s, day: i } = n, a = An(r, s, i), o = Et(Dt(r, s, i), t); let u = Math.floor((a - o + 14 - e) / 7), l; return u < 1 ? (l = r - 1, u = xe(l, e, t)) : u > xe(r, e, t) ? (l = r + 1, u = 1) : l = r, { weekYear: l, weekNumber: u, weekday: o, ...tt(n) } } function Gt(n, e = 4, t = 1) { const { weekYear: r, weekNumber: s, weekday: i } = n, a = Et(Dt(r, 1, e), t), o = ge(r); let u = s * 7 + i - a - 7 + e, l; u < 1 ? (l = r - 1, u += ge(l)) : u > o ? (l = r + 1, u -= ge(r)) : l = r; const { month: h, day: p } = Zn(l, u); return { year: l, month: h, day: p, ...tt(n) } } function lt(n) { const { year: e, month: t, day: r } = n, s = An(e, t, r); return { year: e, ordinal: s, ...tt(n) } } function Jt(n) { const { year: e, ordinal: t } = n, { month: r, day: s } = Zn(e, t); return { year: e, month: r, day: s, ...tt(n) } } function Bt(n, e) { if (!k(n.localWeekday) || !k(n.localWeekNumber) || !k(n.localWeekYear)) { if (!k(n.weekday) || !k(n.weekNumber) || !k(n.weekYear)) throw new ye("Cannot mix locale-based week fields with ISO-based week fields"); return k(n.localWeekday) || (n.weekday = n.localWeekday), k(n.localWeekNumber) || (n.weekNumber = n.localWeekNumber), k(n.localWeekYear) || (n.weekYear = n.localWeekYear), delete n.localWeekday, delete n.localWeekNumber, delete n.localWeekYear, { minDaysInFirstWeek: e.getMinDaysInFirstWeek(), startOfWeek: e.getStartOfWeek() } } else return { minDaysInFirstWeek: 4, startOfWeek: 1 } } function Qr(n, e = 4, t = 1) { const r = Ke(n.weekYear), s = U(n.weekNumber, 1, xe(n.weekYear, e, t)), i = U(n.weekday, 1, 7); return r ? s ? i ? !1 : z("weekday", n.weekday) : z("week", n.weekNumber) : z("weekYear", n.weekYear) } function Kr(n) { const e = Ke(n.year), t = U(n.ordinal, 1, ge(n.year)); return e ? t ? !1 : z("ordinal", n.ordinal) : z("year", n.year) } function Rn(n) { const e = Ke(n.year), t = U(n.month, 1, 12), r = U(n.day, 1, Be(n.year, n.month)); return e ? t ? r ? !1 : z("day", n.day) : z("month", n.month) : z("year", n.year) } function zn(n) { const { hour: e, minute: t, second: r, millisecond: s } = n, i = U(e, 0, 23) || e === 24 && t === 0 && r === 0 && s === 0, a = U(t, 0, 59), o = U(r, 0, 59), u = U(s, 0, 999); return i ? a ? o ? u ? !1 : z("millisecond", s) : z("second", r) : z("minute", t) : z("hour", e) } function k(n) { return typeof n > "u" } function ee(n) { return typeof n == "number" } function Ke(n) { return typeof n == "number" && n % 1 === 0 } function Xr(n) { return typeof n == "string" } function es(n) { return Object.prototype.toString.call(n) === "[object Date]" } function Un() { try { return typeof Intl < "u" && !!Intl.RelativeTimeFormat } catch { return !1 } } function qn() { try { return typeof Intl < "u" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype) } catch { return !1 } } function ts(n) { return Array.isArray(n) ? n : [n] } function jt(n, e, t) { if (n.length !== 0) return n.reduce((r, s) => { const i = [e(s), s]; return r && t(r[0], i[0]) === r[0] ? r : i }, null)[1] } function ns(n, e) { return e.reduce((t, r) => (t[r] = n[r], t), {}) } function Se(n, e) { return Object.prototype.hasOwnProperty.call(n, e) } function St(n) { if (n == null) return null; if (typeof n != "object") throw new V("Week settings must be an object"); if (!U(n.firstDay, 1, 7) || !U(n.minimalDays, 1, 7) || !Array.isArray(n.weekend) || n.weekend.some(e => !U(e, 1, 7))) throw new V("Invalid week settings"); return { firstDay: n.firstDay, minimalDays: n.minimalDays, weekend: Array.from(n.weekend) } } function U(n, e, t) { return Ke(n) && n >= e && n <= t } function rs(n, e) { return n - e * Math.floor(n / e) } function F(n, e = 2) { const t = n < 0; let r; return t ? r = "-" + ("" + -n).padStart(e, "0") : r = ("" + n).padStart(e, "0"), r } function K(n) { if (!(k(n) || n === null || n === "")) return parseInt(n, 10) } function ne(n) { if (!(k(n) || n === null || n === "")) return parseFloat(n) } function Mt(n) { if (!(k(n) || n === null || n === "")) { const e = parseFloat("0." + n) * 1e3; return Math.floor(e) } } function Nt(n, e, t = !1) { const r = 10 ** e; return (t ? Math.trunc : Math.round)(n * r) / r } function We(n) { return n % 4 === 0 && (n % 100 !== 0 || n % 400 === 0) } function ge(n) { return We(n) ? 366 : 365 } function Be(n, e) { const t = rs(e - 1, 12) + 1, r = n + (e - t) / 12; return t === 2 ? We(r) ? 29 : 28 : [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][t - 1] } function Xe(n) { let e = Date.UTC(n.year, n.month - 1, n.day, n.hour, n.minute, n.second, n.millisecond); return n.year < 100 && n.year >= 0 && (e = new Date(e), e.setUTCFullYear(n.year, n.month - 1, n.day)), +e } function Qt(n, e, t) { return -Et(Dt(n, 1, e), t) + e - 1 } function xe(n, e = 4, t = 1) { const r = Qt(n, e, t), s = Qt(n + 1, e, t); return (ge(n) - r + s) / 7 } function Tt(n) { return n > 99 ? n : n > N.twoDigitCutoffYear ? 1900 + n : 2e3 + n } function Hn(n, e, t, r = null) { const s = new Date(n), i = { hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" }; r && (i.timeZone = r); const a = { timeZoneName: e, ...i }, o = new Intl.DateTimeFormat(t, a).formatToParts(s).find(u => u.type.toLowerCase() === "timezonename"); return o ? o.value : null } function et(n, e) { let t = parseInt(n, 10); Number.isNaN(t) && (t = 0); const r = parseInt(e, 10) || 0, s = t < 0 || Object.is(t, -0) ? -r : r; return t * 60 + s } function Yn(n) { const e = Number(n); if (typeof n == "boolean" || n === "" || Number.isNaN(e)) throw new V(`Invalid unit value ${n}`); return e } function je(n, e) { const t = {}; for (const r in n) if (Se(n, r)) { const s = n[r]; if (s == null) continue; t[e(r)] = Yn(s) } return t } function be(n, e) { const t = Math.trunc(Math.abs(n / 60)), r = Math.trunc(Math.abs(n % 60)), s = n >= 0 ? "+" : "-"; switch (e) { case "short": return `${s}${F(t, 2)}:${F(r, 2)}`; case "narrow": return `${s}${t}${r > 0 ? `:${r}` : ""}`; case "techie": return `${s}${F(t, 2)}${F(r, 2)}`; default: throw new RangeError(`Value format ${e} is out of range for property format`) } } function tt(n) { return ns(n, ["hour", "minute", "second", "millisecond"]) } const ss = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], Pn = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], is = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"]; function Gn(n) { switch (n) { case "narrow": return [...is]; case "short": return [...Pn]; case "long": return [...ss]; case "numeric": return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"]; case "2-digit": return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"]; default: return null } } const Jn = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"], Bn = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"], as = ["M", "T", "W", "T", "F", "S", "S"]; function jn(n) { switch (n) { case "narrow": return [...as]; case "short": return [...Bn]; case "long": return [...Jn]; case "numeric": return ["1", "2", "3", "4", "5", "6", "7"]; default: return null } } const Qn = ["AM", "PM"], os = ["Before Christ", "Anno Domini"], us = ["BC", "AD"], ls = ["B", "A"]; function Kn(n) { switch (n) { case "narrow": return [...ls]; case "short": return [...us]; case "long": return [...os]; default: return null } } function cs(n) { return Qn[n.hour < 12 ? 0 : 1] } function fs(n, e) { return jn(e)[n.weekday - 1] } function ds(n, e) { return Gn(e)[n.month - 1] } function hs(n, e) { return Kn(e)[n.year < 0 ? 0 : 1] } function ms(n, e, t = "always", r = !1) { const s = { years: ["year", "yr."], quarters: ["quarter", "qtr."], months: ["month", "mo."], weeks: ["week", "wk."], days: ["day", "day", "days"], hours: ["hour", "hr."], minutes: ["minute", "min."], seconds: ["second", "sec."] }, i = ["hours", "minutes", "seconds"].indexOf(n) === -1; if (t === "auto" && i) { const p = n === "days"; switch (e) { case 1: return p ? "tomorrow" : `next ${s[n][0]}`; case -1: return p ? "yesterday" : `last ${s[n][0]}`; case 0: return p ? "today" : `this ${s[n][0]}` } } const a = Object.is(e, -0) || e < 0, o = Math.abs(e), u = o === 1, l = s[n], h = r ? u ? l[1] : l[2] || l[1] : u ? s[n][0] : n; return a ? `${o} ${h} ago` : `in ${o} ${h}` } function Kt(n, e) { let t = ""; for (const r of n) r.literal ? t += r.val : t += e(r.val); return t } const ys = { D: Ge, DD: gn, DDD: wn, DDDD: kn, t: pn, tt: Sn, ttt: Tn, tttt: On, T: In, TT: vn, TTT: Dn, TTTT: En, f: Mn, ff: Fn, fff: xn, ffff: Wn, F: Nn, FF: bn, FFF: Vn, FFFF: Cn }; class W { static create(e, t = {}) { return new W(e, t) } static parseFormat(e) { let t = null, r = "", s = !1; const i = []; for (let a = 0; a < e.length; a++) { const o = e.charAt(a); o === "'" ? (r.length > 0 && i.push({ literal: s || /^\s+$/.test(r), val: r }), t = null, r = "", s = !s) : s || o === t ? r += o : (r.length > 0 && i.push({ literal: /^\s+$/.test(r), val: r }), r = o, t = o) } return r.length > 0 && i.push({ literal: s || /^\s+$/.test(r), val: r }), i } static macroTokenToFormatOpts(e) { return ys[e] } constructor(e, t) { this.opts = t, this.loc = e, this.systemLoc = null } formatWithSystemDefault(e, t) { return this.systemLoc === null && (this.systemLoc = this.loc.redefaultToSystem()), this.systemLoc.dtFormatter(e, { ...this.opts, ...t }).format() } dtFormatter(e, t = {}) { return this.loc.dtFormatter(e, { ...this.opts, ...t }) } formatDateTime(e, t) { return this.dtFormatter(e, t).format() } formatDateTimeParts(e, t) { return this.dtFormatter(e, t).formatToParts() } formatInterval(e, t) { return this.dtFormatter(e.start, t).dtf.formatRange(e.start.toJSDate(), e.end.toJSDate()) } resolvedOptions(e, t) { return this.dtFormatter(e, t).resolvedOptions() } num(e, t = 0) { if (this.opts.forceSimple) return F(e, t); const r = { ...this.opts }; return t > 0 && (r.padTo = t), this.loc.numberFormatter(r).format(e) } formatDateTimeFromString(e, t) { const r = this.loc.listingMode() === "en", s = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", i = (g, O) => this.loc.extract(e, g, O), a = g => e.isOffsetFixed && e.offset === 0 && g.allowZ ? "Z" : e.isValid ? e.zone.formatOffset(e.ts, g.format) : "", o = () => r ? cs(e) : i({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), u = (g, O) => r ? ds(e, g) : i(O ? { month: g } : { month: g, day: "numeric" }, "month"), l = (g, O) => r ? fs(e, g) : i(O ? { weekday: g } : { weekday: g, month: "long", day: "numeric" }, "weekday"), h = g => { const O = W.macroTokenToFormatOpts(g); return O ? this.formatWithSystemDefault(e, O) : g }, p = g => r ? hs(e, g) : i({ era: g }, "era"), E = g => { switch (g) { case "S": return this.num(e.millisecond); case "u": case "SSS": return this.num(e.millisecond, 3); case "s": return this.num(e.second); case "ss": return this.num(e.second, 2); case "uu": return this.num(Math.floor(e.millisecond / 10), 2); case "uuu": return this.num(Math.floor(e.millisecond / 100)); case "m": return this.num(e.minute); case "mm": return this.num(e.minute, 2); case "h": return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12); case "hh": return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2); case "H": return this.num(e.hour); case "HH": return this.num(e.hour, 2); case "Z": return a({ format: "narrow", allowZ: this.opts.allowZ }); case "ZZ": return a({ format: "short", allowZ: this.opts.allowZ }); case "ZZZ": return a({ format: "techie", allowZ: this.opts.allowZ }); case "ZZZZ": return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale }); case "ZZZZZ": return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale }); case "z": return e.zoneName; case "a": return o(); case "d": return s ? i({ day: "numeric" }, "day") : this.num(e.day); case "dd": return s ? i({ day: "2-digit" }, "day") : this.num(e.day, 2); case "c": return this.num(e.weekday); case "ccc": return l("short", !0); case "cccc": return l("long", !0); case "ccccc": return l("narrow", !0); case "E": return this.num(e.weekday); case "EEE": return l("short", !1); case "EEEE": return l("long", !1); case "EEEEE": return l("narrow", !1); case "L": return s ? i({ month: "numeric", day: "numeric" }, "month") : this.num(e.month); case "LL": return s ? i({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2); case "LLL": return u("short", !0); case "LLLL": return u("long", !0); case "LLLLL": return u("narrow", !0); case "M": return s ? i({ month: "numeric" }, "month") : this.num(e.month); case "MM": return s ? i({ month: "2-digit" }, "month") : this.num(e.month, 2); case "MMM": return u("short", !1); case "MMMM": return u("long", !1); case "MMMMM": return u("narrow", !1); case "y": return s ? i({ year: "numeric" }, "year") : this.num(e.year); case "yy": return s ? i({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2); case "yyyy": return s ? i({ year: "numeric" }, "year") : this.num(e.year, 4); case "yyyyyy": return s ? i({ year: "numeric" }, "year") : this.num(e.year, 6); case "G": return p("short"); case "GG": return p("long"); case "GGGGG": return p("narrow"); case "kk": return this.num(e.weekYear.toString().slice(-2), 2); case "kkkk": return this.num(e.weekYear, 4); case "W": return this.num(e.weekNumber); case "WW": return this.num(e.weekNumber, 2); case "n": return this.num(e.localWeekNumber); case "nn": return this.num(e.localWeekNumber, 2); case "ii": return this.num(e.localWeekYear.toString().slice(-2), 2); case "iiii": return this.num(e.localWeekYear, 4); case "o": return this.num(e.ordinal); case "ooo": return this.num(e.ordinal, 3); case "q": return this.num(e.quarter); case "qq": return this.num(e.quarter, 2); case "X": return this.num(Math.floor(e.ts / 1e3)); case "x": return this.num(e.ts); default: return h(g) } }; return Kt(W.parseFormat(t), E) } formatDurationFromString(e, t) { const r = u => { switch (u[0]) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": return "hour"; case "d": return "day"; case "w": return "week"; case "M": return "month"; case "y": return "year"; default: return null } }, s = u => l => { const h = r(l); return h ? this.num(u.get(h), l.length) : l }, i = W.parseFormat(t), a = i.reduce((u, { literal: l, val: h }) => l ? u : u.concat(h), []), o = e.shiftTo(...a.map(r).filter(u => u)); return Kt(i, s(o)) } } const Xn = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/; function Oe(...n) { const e = n.reduce((t, r) => t + r.source, ""); return RegExp(`^${e}$`) } function Ie(...n) { return e => n.reduce(([t, r, s], i) => { const [a, o, u] = i(e, s); return [{ ...t, ...a }, o || r, u] }, [{}, null, 1]).slice(0, 2) } function ve(n, ...e) { if (n == null) return [null, null]; for (const [t, r] of e) { const s = t.exec(n); if (s) return r(s) } return [null, null] } function er(...n) { return (e, t) => { const r = {}; let s; for (s = 0; s < n.length; s++)r[n[s]] = K(e[t + s]); return [r, null, t + s] } } const tr = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/, gs = `(?:${tr.source}?(?:\\[(${Xn.source})\\])?)?`, Ft = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/, nr = RegExp(`${Ft.source}${gs}`), bt = RegExp(`(?:T${nr.source})?`), ws = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/, ks = /(\d{4})-?W(\d\d)(?:-?(\d))?/, ps = /(\d{4})-?(\d{3})/, Ss = er("weekYear", "weekNumber", "weekDay"), Ts = er("year", "ordinal"), Os = /(\d{4})-(\d\d)-(\d\d)/, rr = RegExp(`${Ft.source} ?(?:${tr.source}|(${Xn.source}))?`), Is = RegExp(`(?: ${rr.source})?`); function we(n, e, t) { const r = n[e]; return k(r) ? t : K(r) } function vs(n, e) { return [{ year: we(n, e), month: we(n, e + 1, 1), day: we(n, e + 2, 1) }, null, e + 3] } function De(n, e) { return [{ hours: we(n, e, 0), minutes: we(n, e + 1, 0), seconds: we(n, e + 2, 0), milliseconds: Mt(n[e + 3]) }, null, e + 4] } function Ce(n, e) { const t = !n[e] && !n[e + 1], r = et(n[e + 1], n[e + 2]), s = t ? null : C.instance(r); return [{}, s, e + 3] } function $e(n, e) { const t = n[e] ? G.create(n[e]) : null; return [{}, t, e + 1] } const Ds = RegExp(`^T?${Ft.source}$`), Es = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/; function Ms(n) { const [e, t, r, s, i, a, o, u, l] = n, h = e[0] === "-", p = u && u[0] === "-", E = (g, O = !1) => g !== void 0 && (O || g && h) ? -g : g; return [{ years: E(ne(t)), months: E(ne(r)), weeks: E(ne(s)), days: E(ne(i)), hours: E(ne(a)), minutes: E(ne(o)), seconds: E(ne(u), u === "-0"), milliseconds: E(Mt(l), p) }] } const Ns = { GMT: 0, EDT: -4 * 60, EST: -5 * 60, CDT: -5 * 60, CST: -6 * 60, MDT: -6 * 60, MST: -7 * 60, PDT: -7 * 60, PST: -8 * 60 }; function xt(n, e, t, r, s, i, a) { const o = { year: e.length === 2 ? Tt(K(e)) : K(e), month: Pn.indexOf(t) + 1, day: K(r), hour: K(s), minute: K(i) }; return a && (o.second = K(a)), n && (o.weekday = n.length > 3 ? Jn.indexOf(n) + 1 : Bn.indexOf(n) + 1), o } const Fs = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/; function bs(n) { const [, e, t, r, s, i, a, o, u, l, h, p] = n, E = xt(e, s, r, t, i, a, o); let g; return u ? g = Ns[u] : l ? g = 0 : g = et(h, p), [E, new C(g)] } function xs(n) { return n.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim() } const Vs = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/, Ws = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/, Cs = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/; function Xt(n) { const [, e, t, r, s, i, a, o] = n; return [xt(e, s, r, t, i, a, o), C.utcInstance] } function $s(n) { const [, e, t, r, s, i, a, o] = n; return [xt(e, o, t, r, s, i, a), C.utcInstance] } const _s = Oe(ws, bt), Ls = Oe(ks, bt), As = Oe(ps, bt), Zs = Oe(nr), sr = Ie(vs, De, Ce, $e), Rs = Ie(Ss, De, Ce, $e), zs = Ie(Ts, De, Ce, $e), Us = Ie(De, Ce, $e); function qs(n) { return ve(n, [_s, sr], [Ls, Rs], [As, zs], [Zs, Us]) } function Hs(n) { return ve(xs(n), [Fs, bs]) } function Ys(n) { return ve(n, [Vs, Xt], [Ws, Xt], [Cs, $s]) } function Ps(n) { return ve(n, [Es, Ms]) } const Gs = Ie(De); function Js(n) { return ve(n, [Ds, Gs]) } const Bs = Oe(Os, Is), js = Oe(rr), Qs = Ie(De, Ce, $e); function Ks(n) { return ve(n, [Bs, sr], [js, Qs]) } const en = "Invalid Duration", ir = { weeks: { days: 7, hours: 7 * 24, minutes: 7 * 24 * 60, seconds: 7 * 24 * 60 * 60, milliseconds: 7 * 24 * 60 * 60 * 1e3 }, days: { hours: 24, minutes: 24 * 60, seconds: 24 * 60 * 60, milliseconds: 24 * 60 * 60 * 1e3 }, hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 }, minutes: { seconds: 60, milliseconds: 60 * 1e3 }, seconds: { milliseconds: 1e3 } }, Xs = { years: { quarters: 4, months: 12, weeks: 52, days: 365, hours: 365 * 24, minutes: 365 * 24 * 60, seconds: 365 * 24 * 60 * 60, milliseconds: 365 * 24 * 60 * 60 * 1e3 }, quarters: { months: 3, weeks: 13, days: 91, hours: 91 * 24, minutes: 91 * 24 * 60, seconds: 91 * 24 * 60 * 60, milliseconds: 91 * 24 * 60 * 60 * 1e3 }, months: { weeks: 4, days: 30, hours: 30 * 24, minutes: 30 * 24 * 60, seconds: 30 * 24 * 60 * 60, milliseconds: 30 * 24 * 60 * 60 * 1e3 }, ...ir }, R = 146097 / 400, le = 146097 / 4800, ei = { years: { quarters: 4, months: 12, weeks: R / 7, days: R, hours: R * 24, minutes: R * 24 * 60, seconds: R * 24 * 60 * 60, milliseconds: R * 24 * 60 * 60 * 1e3 }, quarters: { months: 3, weeks: R / 28, days: R / 4, hours: R * 24 / 4, minutes: R * 24 * 60 / 4, seconds: R * 24 * 60 * 60 / 4, milliseconds: R * 24 * 60 * 60 * 1e3 / 4 }, months: { weeks: le / 7, days: le, hours: le * 24, minutes: le * 24 * 60, seconds: le * 24 * 60 * 60, milliseconds: le * 24 * 60 * 60 * 1e3 }, ...ir }, se = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"], ti = se.slice(0).reverse(); function Q(n, e, t = !1) { const r = { values: t ? e.values : { ...n.values, ...e.values || {} }, loc: n.loc.clone(e.loc), conversionAccuracy: e.conversionAccuracy || n.conversionAccuracy, matrix: e.matrix || n.matrix }; return new I(r) } function ar(n, e) { var t; let r = (t = e.milliseconds) != null ? t : 0; for (const s of ti.slice(1)) e[s] && (r += e[s] * n[s].milliseconds); return r } function tn(n, e) { const t = ar(n, e) < 0 ? -1 : 1; se.reduceRight((r, s) => { if (k(e[s])) return r; if (r) { const i = e[r] * t, a = n[s][r], o = Math.floor(i / a); e[s] += o * t, e[r] -= o * a * t } return s }, null), se.reduce((r, s) => { if (k(e[s])) return r; if (r) { const i = e[r] % 1; e[r] -= i, e[s] += i * n[r][s] } return s }, null) } function ni(n) { const e = {}; for (const [t, r] of Object.entries(n)) r !== 0 && (e[t] = r); return e } class I { constructor(e) { const t = e.conversionAccuracy === "longterm" || !1; let r = t ? ei : Xs; e.matrix && (r = e.matrix), this.values = e.values, this.loc = e.loc || D.create(), this.conversionAccuracy = t ? "longterm" : "casual", this.invalid = e.invalid || null, this.matrix = r, this.isLuxonDuration = !0 } static fromMillis(e, t) { return I.fromObject({ milliseconds: e }, t) } static fromObject(e, t = {}) { if (e == null || typeof e != "object") throw new V(`Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`); return new I({ values: je(e, I.normalizeUnit), loc: D.fromObject(t), conversionAccuracy: t.conversionAccuracy, matrix: t.matrix }) } static fromDurationLike(e) { if (ee(e)) return I.fromMillis(e); if (I.isDuration(e)) return e; if (typeof e == "object") return I.fromObject(e); throw new V(`Unknown duration argument ${e} of type ${typeof e}`) } static fromISO(e, t) { const [r] = Ps(e); return r ? I.fromObject(r, t) : I.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static fromISOTime(e, t) { const [r] = Js(e); return r ? I.fromObject(r, t) : I.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static invalid(e, t = null) { if (!e) throw new V("need to specify a reason the Duration is invalid"); const r = e instanceof Y ? e : new Y(e, t); if (N.throwOnInvalid) throw new Mr(r); return new I({ invalid: r }) } static normalizeUnit(e) { const t = { year: "years", years: "years", quarter: "quarters", quarters: "quarters", month: "months", months: "months", week: "weeks", weeks: "weeks", day: "days", days: "days", hour: "hours", hours: "hours", minute: "minutes", minutes: "minutes", second: "seconds", seconds: "seconds", millisecond: "milliseconds", milliseconds: "milliseconds" }[e && e.toLowerCase()]; if (!t) throw new yn(e); return t } static isDuration(e) { return e && e.isLuxonDuration || !1 } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } toFormat(e, t = {}) { const r = { ...t, floor: t.round !== !1 && t.floor !== !1 }; return this.isValid ? W.create(this.loc, r).formatDurationFromString(this, e) : en } toHuman(e = {}) { if (!this.isValid) return en; const t = se.map(r => { const s = this.values[r]; return k(s) ? null : this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: r.slice(0, -1) }).format(s) }).filter(r => r); return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(t) } toObject() { return this.isValid ? { ...this.values } : {} } toISO() { if (!this.isValid) return null; let e = "P"; return this.years !== 0 && (e += this.years + "Y"), (this.months !== 0 || this.quarters !== 0) && (e += this.months + this.quarters * 3 + "M"), this.weeks !== 0 && (e += this.weeks + "W"), this.days !== 0 && (e += this.days + "D"), (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) && (e += "T"), this.hours !== 0 && (e += this.hours + "H"), this.minutes !== 0 && (e += this.minutes + "M"), (this.seconds !== 0 || this.milliseconds !== 0) && (e += Nt(this.seconds + this.milliseconds / 1e3, 3) + "S"), e === "P" && (e += "T0S"), e } toISOTime(e = {}) { if (!this.isValid) return null; const t = this.toMillis(); return t < 0 || t >= 864e5 ? null : (e = { suppressMilliseconds: !1, suppressSeconds: !1, includePrefix: !1, format: "extended", ...e, includeOffset: !1 }, w.fromMillis(t, { zone: "UTC" }).toISOTime(e)) } toJSON() { return this.toISO() } toString() { return this.toISO() } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `Duration { values: ${JSON.stringify(this.values)} }` : `Duration { Invalid, reason: ${this.invalidReason} }` } toMillis() { return this.isValid ? ar(this.matrix, this.values) : NaN } valueOf() { return this.toMillis() } plus(e) { if (!this.isValid) return this; const t = I.fromDurationLike(e), r = {}; for (const s of se) (Se(t.values, s) || Se(this.values, s)) && (r[s] = t.get(s) + this.get(s)); return Q(this, { values: r }, !0) } minus(e) { if (!this.isValid) return this; const t = I.fromDurationLike(e); return this.plus(t.negate()) } mapUnits(e) { if (!this.isValid) return this; const t = {}; for (const r of Object.keys(this.values)) t[r] = Yn(e(this.values[r], r)); return Q(this, { values: t }, !0) } get(e) { return this[I.normalizeUnit(e)] } set(e) { if (!this.isValid) return this; const t = { ...this.values, ...je(e, I.normalizeUnit) }; return Q(this, { values: t }) } reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r, matrix: s } = {}) { const a = { loc: this.loc.clone({ locale: e, numberingSystem: t }), matrix: s, conversionAccuracy: r }; return Q(this, a) } as(e) { return this.isValid ? this.shiftTo(e).get(e) : NaN } normalize() { if (!this.isValid) return this; const e = this.toObject(); return tn(this.matrix, e), Q(this, { values: e }, !0) } rescale() { if (!this.isValid) return this; const e = ni(this.normalize().shiftToAll().toObject()); return Q(this, { values: e }, !0) } shiftTo(...e) { if (!this.isValid) return this; if (e.length === 0) return this; e = e.map(a => I.normalizeUnit(a)); const t = {}, r = {}, s = this.toObject(); let i; for (const a of se) if (e.indexOf(a) >= 0) { i = a; let o = 0; for (const l in r) o += this.matrix[l][a] * r[l], r[l] = 0; ee(s[a]) && (o += s[a]); const u = Math.trunc(o); t[a] = u, r[a] = (o * 1e3 - u * 1e3) / 1e3 } else ee(s[a]) && (r[a] = s[a]); for (const a in r) r[a] !== 0 && (t[i] += a === i ? r[a] : r[a] / this.matrix[i][a]); return tn(this.matrix, t), Q(this, { values: t }, !0) } shiftToAll() { return this.isValid ? this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds") : this } negate() { if (!this.isValid) return this; const e = {}; for (const t of Object.keys(this.values)) e[t] = this.values[t] === 0 ? 0 : -this.values[t]; return Q(this, { values: e }, !0) } get years() { return this.isValid ? this.values.years || 0 : NaN } get quarters() { return this.isValid ? this.values.quarters || 0 : NaN } get months() { return this.isValid ? this.values.months || 0 : NaN } get weeks() { return this.isValid ? this.values.weeks || 0 : NaN } get days() { return this.isValid ? this.values.days || 0 : NaN } get hours() { return this.isValid ? this.values.hours || 0 : NaN } get minutes() { return this.isValid ? this.values.minutes || 0 : NaN } get seconds() { return this.isValid ? this.values.seconds || 0 : NaN } get milliseconds() { return this.isValid ? this.values.milliseconds || 0 : NaN } get isValid() { return this.invalid === null } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } equals(e) { if (!this.isValid || !e.isValid || !this.loc.equals(e.loc)) return !1; function t(r, s) { return r === void 0 || r === 0 ? s === void 0 || s === 0 : r === s } for (const r of se) if (!t(this.values[r], e.values[r])) return !1; return !0 } } const ce = "Invalid Interval"; function ri(n, e) { return !n || !n.isValid ? M.invalid("missing or invalid start") : !e || !e.isValid ? M.invalid("missing or invalid end") : e < n ? M.invalid("end before start", `The end of an interval must be after its start, but you had start=${n.toISO()} and end=${e.toISO()}`) : null } class M { constructor(e) { this.s = e.start, this.e = e.end, this.invalid = e.invalid || null, this.isLuxonInterval = !0 } static invalid(e, t = null) { if (!e) throw new V("need to specify a reason the Interval is invalid"); const r = e instanceof Y ? e : new Y(e, t); if (N.throwOnInvalid) throw new Er(r); return new M({ invalid: r }) } static fromDateTimes(e, t) { const r = Ee(e), s = Ee(t), i = ri(r, s); return i ?? new M({ start: r, end: s }) } static after(e, t) { const r = I.fromDurationLike(t), s = Ee(e); return M.fromDateTimes(s, s.plus(r)) } static before(e, t) { const r = I.fromDurationLike(t), s = Ee(e); return M.fromDateTimes(s.minus(r), s) } static fromISO(e, t) { const [r, s] = (e || "").split("/", 2); if (r && s) { let i, a; try { i = w.fromISO(r, t), a = i.isValid } catch { a = !1 } let o, u; try { o = w.fromISO(s, t), u = o.isValid } catch { u = !1 } if (a && u) return M.fromDateTimes(i, o); if (a) { const l = I.fromISO(s, t); if (l.isValid) return M.after(i, l) } else if (u) { const l = I.fromISO(r, t); if (l.isValid) return M.before(o, l) } } return M.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`) } static isInterval(e) { return e && e.isLuxonInterval || !1 } get start() { return this.isValid ? this.s : null } get end() { return this.isValid ? this.e : null } get isValid() { return this.invalidReason === null } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } length(e = "milliseconds") { return this.isValid ? this.toDuration(e).get(e) : NaN } count(e = "milliseconds", t) { if (!this.isValid) return NaN; const r = this.start.startOf(e, t); let s; return t != null && t.useLocaleWeeks ? s = this.end.reconfigure({ locale: r.locale }) : s = this.end, s = s.startOf(e, t), Math.floor(s.diff(r, e).get(e)) + (s.valueOf() !== this.end.valueOf()) } hasSame(e) { return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : !1 } isEmpty() { return this.s.valueOf() === this.e.valueOf() } isAfter(e) { return this.isValid ? this.s > e : !1 } isBefore(e) { return this.isValid ? this.e <= e : !1 } contains(e) { return this.isValid ? this.s <= e && this.e > e : !1 } set({ start: e, end: t } = {}) { return this.isValid ? M.fromDateTimes(e || this.s, t || this.e) : this } splitAt(...e) { if (!this.isValid) return []; const t = e.map(Ee).filter(a => this.contains(a)).sort((a, o) => a.toMillis() - o.toMillis()), r = []; let { s } = this, i = 0; for (; s < this.e;) { const a = t[i] || this.e, o = +a > +this.e ? this.e : a; r.push(M.fromDateTimes(s, o)), s = o, i += 1 } return r } splitBy(e) { const t = I.fromDurationLike(e); if (!this.isValid || !t.isValid || t.as("milliseconds") === 0) return []; let { s: r } = this, s = 1, i; const a = []; for (; r < this.e;) { const o = this.start.plus(t.mapUnits(u => u * s)); i = +o > +this.e ? this.e : o, a.push(M.fromDateTimes(r, i)), r = i, s += 1 } return a } divideEqually(e) { return this.isValid ? this.splitBy(this.length() / e).slice(0, e) : [] } overlaps(e) { return this.e > e.s && this.s < e.e } abutsStart(e) { return this.isValid ? +this.e == +e.s : !1 } abutsEnd(e) { return this.isValid ? +e.e == +this.s : !1 } engulfs(e) { return this.isValid ? this.s <= e.s && this.e >= e.e : !1 } equals(e) { return !this.isValid || !e.isValid ? !1 : this.s.equals(e.s) && this.e.equals(e.e) } intersection(e) { if (!this.isValid) return this; const t = this.s > e.s ? this.s : e.s, r = this.e < e.e ? this.e : e.e; return t >= r ? null : M.fromDateTimes(t, r) } union(e) { if (!this.isValid) return this; const t = this.s < e.s ? this.s : e.s, r = this.e > e.e ? this.e : e.e; return M.fromDateTimes(t, r) } static merge(e) { const [t, r] = e.sort((s, i) => s.s - i.s).reduce(([s, i], a) => i ? i.overlaps(a) || i.abutsStart(a) ? [s, i.union(a)] : [s.concat([i]), a] : [s, a], [[], null]); return r && t.push(r), t } static xor(e) { let t = null, r = 0; const s = [], i = e.map(u => [{ time: u.s, type: "s" }, { time: u.e, type: "e" }]), a = Array.prototype.concat(...i), o = a.sort((u, l) => u.time - l.time); for (const u of o) r += u.type === "s" ? 1 : -1, r === 1 ? t = u.time : (t && +t != +u.time && s.push(M.fromDateTimes(t, u.time)), t = null); return M.merge(s) } difference(...e) { return M.xor([this].concat(e)).map(t => this.intersection(t)).filter(t => t && !t.isEmpty()) } toString() { return this.isValid ? `[${this.s.toISO()} – ${this.e.toISO()})` : ce } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }` : `Interval { Invalid, reason: ${this.invalidReason} }` } toLocaleString(e = Ge, t = {}) { return this.isValid ? W.create(this.s.loc.clone(t), e).formatInterval(this) : ce } toISO(e) { return this.isValid ? `${this.s.toISO(e)}/${this.e.toISO(e)}` : ce } toISODate() { return this.isValid ? `${this.s.toISODate()}/${this.e.toISODate()}` : ce } toISOTime(e) { return this.isValid ? `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}` : ce } toFormat(e, { separator: t = " – " } = {}) { return this.isValid ? `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}` : ce } toDuration(e, t) { return this.isValid ? this.e.diff(this.s, e, t) : I.invalid(this.invalidReason) } mapEndpoints(e) { return M.fromDateTimes(e(this.s), e(this.e)) } } class Ne { static hasDST(e = N.defaultZone) { const t = w.now().setZone(e).set({ month: 12 }); return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset } static isValidIANAZone(e) { return G.isValidZone(e) } static normalizeZone(e) { return X(e, N.defaultZone) } static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) { return (t || D.create(e)).getStartOfWeek() } static getMinimumDaysInFirstWeek({ locale: e = null, locObj: t = null } = {}) { return (t || D.create(e)).getMinDaysInFirstWeek() } static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) { return (t || D.create(e)).getWeekendDays().slice() } static months(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: i = "gregory" } = {}) { return (s || D.create(t, r, i)).months(e) } static monthsFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null, outputCalendar: i = "gregory" } = {}) { return (s || D.create(t, r, i)).months(e, !0) } static weekdays(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) { return (s || D.create(t, r, null)).weekdays(e) } static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: s = null } = {}) { return (s || D.create(t, r, null)).weekdays(e, !0) } static meridiems({ locale: e = null } = {}) { return D.create(e).meridiems() } static eras(e = "short", { locale: t = null } = {}) { return D.create(t, null, "gregory").eras(e) } static features() { return { relative: Un(), localeWeek: qn() } } } function nn(n, e) { const t = s => s.toUTC(0, { keepLocalTime: !0 }).startOf("day").valueOf(), r = t(e) - t(n); return Math.floor(I.fromMillis(r).as("days")) } function si(n, e, t) { const r = [["years", (u, l) => l.year - u.year], ["quarters", (u, l) => l.quarter - u.quarter + (l.year - u.year) * 4], ["months", (u, l) => l.month - u.month + (l.year - u.year) * 12], ["weeks", (u, l) => { const h = nn(u, l); return (h - h % 7) / 7 }], ["days", nn]], s = {}, i = n; let a, o; for (const [u, l] of r) t.indexOf(u) >= 0 && (a = u, s[u] = l(n, e), o = i.plus(s), o > e ? (s[u]--, n = i.plus(s), n > e && (o = n, s[u]--, n = i.plus(s))) : n = o); return [n, s, o, a] } function ii(n, e, t, r) { let [s, i, a, o] = si(n, e, t); const u = e - s, l = t.filter(p => ["hours", "minutes", "seconds", "milliseconds"].indexOf(p) >= 0); l.length === 0 && (a < e && (a = s.plus({ [o]: 1 })), a !== s && (i[o] = (i[o] || 0) + u / (a - s))); const h = I.fromObject(i, r); return l.length > 0 ? I.fromMillis(u, r).shiftTo(...l).plus(h) : h } const ai = "missing Intl.DateTimeFormat.formatToParts support"; function v(n, e = t => t) { return { regex: n, deser: ([t]) => e(Br(t)) } } const oi = " ", or = `[ ${oi}]`, ur = new RegExp(or, "g"); function ui(n) { return n.replace(/\./g, "\\.?").replace(ur, or) } function rn(n) { return n.replace(/\./g, "").replace(ur, " ").toLowerCase() } function H(n, e) { return n === null ? null : { regex: RegExp(n.map(ui).join("|")), deser: ([t]) => n.findIndex(r => rn(t) === rn(r)) + e } } function sn(n, e) { return { regex: n, deser: ([, t, r]) => et(t, r), groups: e } } function Re(n) { return { regex: n, deser: ([e]) => e } } function li(n) { return n.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&") } function ci(n, e) { const t = q(e), r = q(e, "{2}"), s = q(e, "{3}"), i = q(e, "{4}"), a = q(e, "{6}"), o = q(e, "{1,2}"), u = q(e, "{1,3}"), l = q(e, "{1,6}"), h = q(e, "{1,9}"), p = q(e, "{2,4}"), E = q(e, "{4,6}"), g = A => ({ regex: RegExp(li(A.val)), deser: ([B]) => B, literal: !0 }), J = (A => { if (n.literal) return g(A); switch (A.val) { case "G": return H(e.eras("short"), 0); case "GG": return H(e.eras("long"), 0); case "y": return v(l); case "yy": return v(p, Tt); case "yyyy": return v(i); case "yyyyy": return v(E); case "yyyyyy": return v(a); case "M": return v(o); case "MM": return v(r); case "MMM": return H(e.months("short", !0), 1); case "MMMM": return H(e.months("long", !0), 1); case "L": return v(o); case "LL": return v(r); case "LLL": return H(e.months("short", !1), 1); case "LLLL": return H(e.months("long", !1), 1); case "d": return v(o); case "dd": return v(r); case "o": return v(u); case "ooo": return v(s); case "HH": return v(r); case "H": return v(o); case "hh": return v(r); case "h": return v(o); case "mm": return v(r); case "m": return v(o); case "q": return v(o); case "qq": return v(r); case "s": return v(o); case "ss": return v(r); case "S": return v(u); case "SSS": return v(s); case "u": return Re(h); case "uu": return Re(o); case "uuu": return v(t); case "a": return H(e.meridiems(), 0); case "kkkk": return v(i); case "kk": return v(p, Tt); case "W": return v(o); case "WW": return v(r); case "E": case "c": return v(t); case "EEE": return H(e.weekdays("short", !1), 1); case "EEEE": return H(e.weekdays("long", !1), 1); case "ccc": return H(e.weekdays("short", !0), 1); case "cccc": return H(e.weekdays("long", !0), 1); case "Z": case "ZZ": return sn(new RegExp(`([+-]${o.source})(?::(${r.source}))?`), 2); case "ZZZ": return sn(new RegExp(`([+-]${o.source})(${r.source})?`), 2); case "z": return Re(/[a-z_+-/]{1,256}?/i); case " ": return Re(/[^\S\n\r]/); default: return g(A) } })(n) || { invalidReason: ai }; return J.token = n, J } const fi = { year: { "2-digit": "yy", numeric: "yyyyy" }, month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" }, day: { numeric: "d", "2-digit": "dd" }, weekday: { short: "EEE", long: "EEEE" }, dayperiod: "a", dayPeriod: "a", hour12: { numeric: "h", "2-digit": "hh" }, hour24: { numeric: "H", "2-digit": "HH" }, minute: { numeric: "m", "2-digit": "mm" }, second: { numeric: "s", "2-digit": "ss" }, timeZoneName: { long: "ZZZZZ", short: "ZZZ" } }; function di(n, e, t) { const { type: r, value: s } = n; if (r === "literal") { const u = /^\s+$/.test(s); return { literal: !u, val: u ? " " : s } } const i = e[r]; let a = r; r === "hour" && (e.hour12 != null ? a = e.hour12 ? "hour12" : "hour24" : e.hourCycle != null ? e.hourCycle === "h11" || e.hourCycle === "h12" ? a = "hour12" : a = "hour24" : a = t.hour12 ? "hour12" : "hour24"); let o = fi[a]; if (typeof o == "object" && (o = o[i]), o) return { literal: !1, val: o } } function hi(n) { return [`^${n.map(t => t.regex).reduce((t, r) => `${t}(${r.source})`, "")}$`, n] } function mi(n, e, t) { const r = n.match(e); if (r) { const s = {}; let i = 1; for (const a in t) if (Se(t, a)) { const o = t[a], u = o.groups ? o.groups + 1 : 1; !o.literal && o.token && (s[o.token.val[0]] = o.deser(r.slice(i, i + u))), i += u } return [r, s] } else return [r, {}] } function yi(n) { const e = i => { switch (i) { case "S": return "millisecond"; case "s": return "second"; case "m": return "minute"; case "h": case "H": return "hour"; case "d": return "day"; case "o": return "ordinal"; case "L": case "M": return "month"; case "y": return "year"; case "E": case "c": return "weekday"; case "W": return "weekNumber"; case "k": return "weekYear"; case "q": return "quarter"; default: return null } }; let t = null, r; return k(n.z) || (t = G.create(n.z)), k(n.Z) || (t || (t = new C(n.Z)), r = n.Z), k(n.q) || (n.M = (n.q - 1) * 3 + 1), k(n.h) || (n.h < 12 && n.a === 1 ? n.h += 12 : n.h === 12 && n.a === 0 && (n.h = 0)), n.G === 0 && n.y && (n.y = -n.y), k(n.u) || (n.S = Mt(n.u)), [Object.keys(n).reduce((i, a) => { const o = e(a); return o && (i[o] = n[a]), i }, {}), t, r] } let ct = null; function gi() { return ct || (ct = w.fromMillis(1555555555555)), ct } function wi(n, e) { if (n.literal) return n; const t = W.macroTokenToFormatOpts(n.val), r = dr(t, e); return r == null || r.includes(void 0) ? n : r } function lr(n, e) { return Array.prototype.concat(...n.map(t => wi(t, e))) } class cr { constructor(e, t) { if (this.locale = e, this.format = t, this.tokens = lr(W.parseFormat(t), e), this.units = this.tokens.map(r => ci(r, e)), this.disqualifyingUnit = this.units.find(r => r.invalidReason), !this.disqualifyingUnit) { const [r, s] = hi(this.units); this.regex = RegExp(r, "i"), this.handlers = s } } explainFromTokens(e) { if (this.isValid) { const [t, r] = mi(e, this.regex, this.handlers), [s, i, a] = r ? yi(r) : [null, null, void 0]; if (Se(r, "a") && Se(r, "H")) throw new ye("Can't include meridiem when specifying 24-hour format"); return { input: e, tokens: this.tokens, regex: this.regex, rawMatches: t, matches: r, result: s, zone: i, specificOffset: a } } else return { input: e, tokens: this.tokens, invalidReason: this.invalidReason } } get isValid() { return !this.disqualifyingUnit } get invalidReason() { return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null } } function fr(n, e, t) { return new cr(n, t).explainFromTokens(e) } function ki(n, e, t) { const { result: r, zone: s, specificOffset: i, invalidReason: a } = fr(n, e, t); return [r, s, i, a] } function dr(n, e) { if (!n) return null; const r = W.create(e, n).dtFormatter(gi()), s = r.formatToParts(), i = r.resolvedOptions(); return s.map(a => di(a, n, i)) } const ft = "Invalid DateTime", an = 864e13; function Fe(n) { return new Y("unsupported zone", `the zone "${n.name}" is not supported`) } function dt(n) { return n.weekData === null && (n.weekData = Je(n.c)), n.weekData } function ht(n) { return n.localWeekData === null && (n.localWeekData = Je(n.c, n.loc.getMinDaysInFirstWeek(), n.loc.getStartOfWeek())), n.localWeekData } function re(n, e) { const t = { ts: n.ts, zone: n.zone, c: n.c, o: n.o, loc: n.loc, invalid: n.invalid }; return new w({ ...t, ...e, old: t }) } function hr(n, e, t) { let r = n - e * 60 * 1e3; const s = t.offset(r); if (e === s) return [r, e]; r -= (s - e) * 60 * 1e3; const i = t.offset(r); return s === i ? [r, s] : [n - Math.min(s, i) * 60 * 1e3, Math.max(s, i)] } function ze(n, e) { n += e * 60 * 1e3; const t = new Date(n); return { year: t.getUTCFullYear(), month: t.getUTCMonth() + 1, day: t.getUTCDate(), hour: t.getUTCHours(), minute: t.getUTCMinutes(), second: t.getUTCSeconds(), millisecond: t.getUTCMilliseconds() } } function He(n, e, t) { return hr(Xe(n), e, t) } function on(n, e) { const t = n.o, r = n.c.year + Math.trunc(e.years), s = n.c.month + Math.trunc(e.months) + Math.trunc(e.quarters) * 3, i = { ...n.c, year: r, month: s, day: Math.min(n.c.day, Be(r, s)) + Math.trunc(e.days) + Math.trunc(e.weeks) * 7 }, a = I.fromObject({ years: e.years - Math.trunc(e.years), quarters: e.quarters - Math.trunc(e.quarters), months: e.months - Math.trunc(e.months), weeks: e.weeks - Math.trunc(e.weeks), days: e.days - Math.trunc(e.days), hours: e.hours, minutes: e.minutes, seconds: e.seconds, milliseconds: e.milliseconds }).as("milliseconds"), o = Xe(i); let [u, l] = hr(o, t, n.zone); return a !== 0 && (u += a, l = n.zone.offset(u)), { ts: u, o: l } } function fe(n, e, t, r, s, i) { const { setZone: a, zone: o } = t; if (n && Object.keys(n).length !== 0 || e) { const u = e || o, l = w.fromObject(n, { ...t, zone: u, specificOffset: i }); return a ? l : l.setZone(o) } else return w.invalid(new Y("unparsable", `the input "${s}" can't be parsed as ${r}`)) } function Ue(n, e, t = !0) { return n.isValid ? W.create(D.create("en-US"), { allowZ: t, forceSimple: !0 }).formatDateTimeFromString(n, e) : null } function mt(n, e) { const t = n.c.year > 9999 || n.c.year < 0; let r = ""; return t && n.c.year >= 0 && (r += "+"), r += F(n.c.year, t ? 6 : 4), e ? (r += "-", r += F(n.c.month), r += "-", r += F(n.c.day)) : (r += F(n.c.month), r += F(n.c.day)), r } function un(n, e, t, r, s, i) { let a = F(n.c.hour); return e ? (a += ":", a += F(n.c.minute), (n.c.millisecond !== 0 || n.c.second !== 0 || !t) && (a += ":")) : a += F(n.c.minute), (n.c.millisecond !== 0 || n.c.second !== 0 || !t) && (a += F(n.c.second), (n.c.millisecond !== 0 || !r) && (a += ".", a += F(n.c.millisecond, 3))), s && (n.isOffsetFixed && n.offset === 0 && !i ? a += "Z" : n.o < 0 ? (a += "-", a += F(Math.trunc(-n.o / 60)), a += ":", a += F(Math.trunc(-n.o % 60))) : (a += "+", a += F(Math.trunc(n.o / 60)), a += ":", a += F(Math.trunc(n.o % 60)))), i && (a += "[" + n.zone.ianaName + "]"), a } const mr = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, pi = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, Si = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 }, yr = ["year", "month", "day", "hour", "minute", "second", "millisecond"], Ti = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"], Oi = ["year", "ordinal", "hour", "minute", "second", "millisecond"]; function Ii(n) { const e = { year: "year", years: "year", month: "month", months: "month", day: "day", days: "day", hour: "hour", hours: "hour", minute: "minute", minutes: "minute", quarter: "quarter", quarters: "quarter", second: "second", seconds: "second", millisecond: "millisecond", milliseconds: "millisecond", weekday: "weekday", weekdays: "weekday", weeknumber: "weekNumber", weeksnumber: "weekNumber", weeknumbers: "weekNumber", weekyear: "weekYear", weekyears: "weekYear", ordinal: "ordinal" }[n.toLowerCase()]; if (!e) throw new yn(n); return e } function ln(n) { switch (n.toLowerCase()) { case "localweekday": case "localweekdays": return "localWeekday"; case "localweeknumber": case "localweeknumbers": return "localWeekNumber"; case "localweekyear": case "localweekyears": return "localWeekYear"; default: return Ii(n) } } function vi(n) { return Pe[n] || (Ye === void 0 && (Ye = N.now()), Pe[n] = n.offset(Ye)), Pe[n] } function cn(n, e) { const t = X(e.zone, N.defaultZone); if (!t.isValid) return w.invalid(Fe(t)); const r = D.fromObject(e); let s, i; if (k(n.year)) s = N.now(); else { for (const u of yr) k(n[u]) && (n[u] = mr[u]); const a = Rn(n) || zn(n); if (a) return w.invalid(a); const o = vi(t);[s, i] = He(n, o, t) } return new w({ ts: s, zone: t, loc: r, o: i }) } function fn(n, e, t) { const r = k(t.round) ? !0 : t.round, s = (a, o) => (a = Nt(a, r || t.calendary ? 0 : 2, !0), e.loc.clone(t).relFormatter(t).format(a, o)), i = a => t.calendary ? e.hasSame(n, a) ? 0 : e.startOf(a).diff(n.startOf(a), a).get(a) : e.diff(n, a).get(a); if (t.unit) return s(i(t.unit), t.unit); for (const a of t.units) { const o = i(a); if (Math.abs(o) >= 1) return s(o, a) } return s(n > e ? -0 : 0, t.units[t.units.length - 1]) } function dn(n) { let e = {}, t; return n.length > 0 && typeof n[n.length - 1] == "object" ? (e = n[n.length - 1], t = Array.from(n).slice(0, n.length - 1)) : t = Array.from(n), [e, t] } let Ye, Pe = {}; class w { constructor(e) { const t = e.zone || N.defaultZone; let r = e.invalid || (Number.isNaN(e.ts) ? new Y("invalid input") : null) || (t.isValid ? null : Fe(t)); this.ts = k(e.ts) ? N.now() : e.ts; let s = null, i = null; if (!r) if (e.old && e.old.ts === this.ts && e.old.zone.equals(t)) [s, i] = [e.old.c, e.old.o]; else { const o = ee(e.o) && !e.old ? e.o : t.offset(this.ts); s = ze(this.ts, o), r = Number.isNaN(s.year) ? new Y("invalid input") : null, s = r ? null : s, i = r ? null : o } this._zone = t, this.loc = e.loc || D.create(), this.invalid = r, this.weekData = null, this.localWeekData = null, this.c = s, this.o = i, this.isLuxonDateTime = !0 } static now() { return new w({}) } static local() { const [e, t] = dn(arguments), [r, s, i, a, o, u, l] = t; return cn({ year: r, month: s, day: i, hour: a, minute: o, second: u, millisecond: l }, e) } static utc() { const [e, t] = dn(arguments), [r, s, i, a, o, u, l] = t; return e.zone = C.utcInstance, cn({ year: r, month: s, day: i, hour: a, minute: o, second: u, millisecond: l }, e) } static fromJSDate(e, t = {}) { const r = es(e) ? e.valueOf() : NaN; if (Number.isNaN(r)) return w.invalid("invalid input"); const s = X(t.zone, N.defaultZone); return s.isValid ? new w({ ts: r, zone: s, loc: D.fromObject(t) }) : w.invalid(Fe(s)) } static fromMillis(e, t = {}) { if (ee(e)) return e < -an || e > an ? w.invalid("Timestamp out of range") : new w({ ts: e, zone: X(t.zone, N.defaultZone), loc: D.fromObject(t) }); throw new V(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`) } static fromSeconds(e, t = {}) { if (ee(e)) return new w({ ts: e * 1e3, zone: X(t.zone, N.defaultZone), loc: D.fromObject(t) }); throw new V("fromSeconds requires a numerical input") } static fromObject(e, t = {}) { e = e || {}; const r = X(t.zone, N.defaultZone); if (!r.isValid) return w.invalid(Fe(r)); const s = D.fromObject(t), i = je(e, ln), { minDaysInFirstWeek: a, startOfWeek: o } = Bt(i, s), u = N.now(), l = k(t.specificOffset) ? r.offset(u) : t.specificOffset, h = !k(i.ordinal), p = !k(i.year), E = !k(i.month) || !k(i.day), g = p || E, O = i.weekYear || i.weekNumber; if ((g || h) && O) throw new ye("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (E && h) throw new ye("Can't mix ordinal dates with month/day"); const J = O || i.weekday && !g; let A, B, te = ze(u, l); J ? (A = Ti, B = pi, te = Je(te, a, o)) : h ? (A = Oi, B = Si, te = lt(te)) : (A = yr, B = mr); let _e = !1; for (const Z of A) { const at = i[Z]; k(at) ? _e ? i[Z] = B[Z] : i[Z] = te[Z] : _e = !0 } const nt = J ? Qr(i, a, o) : h ? Kr(i) : Rn(i), Le = nt || zn(i); if (Le) return w.invalid(Le); const rt = J ? Gt(i, a, o) : h ? Jt(i) : i, [st, it] = He(rt, l, r), x = new w({ ts: st, zone: r, o: it, loc: s }); return i.weekday && g && e.weekday !== x.weekday ? w.invalid("mismatched weekday", `you can't specify both a weekday of ${i.weekday} and a date of ${x.toISO()}`) : x.isValid ? x : w.invalid(x.invalid) } static fromISO(e, t = {}) { const [r, s] = qs(e); return fe(r, s, t, "ISO 8601", e) } static fromRFC2822(e, t = {}) { const [r, s] = Hs(e); return fe(r, s, t, "RFC 2822", e) } static fromHTTP(e, t = {}) { const [r, s] = Ys(e); return fe(r, s, t, "HTTP", t) } static fromFormat(e, t, r = {}) { if (k(e) || k(t)) throw new V("fromFormat requires an input string and a format"); const { locale: s = null, numberingSystem: i = null } = r, a = D.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 }), [o, u, l, h] = ki(a, e, t); return h ? w.invalid(h) : fe(o, u, r, `format ${t}`, e, l) } static fromString(e, t, r = {}) { return w.fromFormat(e, t, r) } static fromSQL(e, t = {}) { const [r, s] = Ks(e); return fe(r, s, t, "SQL", e) } static invalid(e, t = null) { if (!e) throw new V("need to specify a reason the DateTime is invalid"); const r = e instanceof Y ? e : new Y(e, t); if (N.throwOnInvalid) throw new Dr(r); return new w({ invalid: r }) } static isDateTime(e) { return e && e.isLuxonDateTime || !1 } static parseFormatForOpts(e, t = {}) { const r = dr(e, D.fromObject(t)); return r ? r.map(s => s ? s.val : null).join("") : null } static expandFormat(e, t = {}) { return lr(W.parseFormat(e), D.fromObject(t)).map(s => s.val).join("") } static resetCache() { Ye = void 0, Pe = {} } get(e) { return this[e] } get isValid() { return this.invalid === null } get invalidReason() { return this.invalid ? this.invalid.reason : null } get invalidExplanation() { return this.invalid ? this.invalid.explanation : null } get locale() { return this.isValid ? this.loc.locale : null } get numberingSystem() { return this.isValid ? this.loc.numberingSystem : null } get outputCalendar() { return this.isValid ? this.loc.outputCalendar : null } get zone() { return this._zone } get zoneName() { return this.isValid ? this.zone.name : null } get year() { return this.isValid ? this.c.year : NaN } get quarter() { return this.isValid ? Math.ceil(this.c.month / 3) : NaN } get month() { return this.isValid ? this.c.month : NaN } get day() { return this.isValid ? this.c.day : NaN } get hour() { return this.isValid ? this.c.hour : NaN } get minute() { return this.isValid ? this.c.minute : NaN } get second() { return this.isValid ? this.c.second : NaN } get millisecond() { return this.isValid ? this.c.millisecond : NaN } get weekYear() { return this.isValid ? dt(this).weekYear : NaN } get weekNumber() { return this.isValid ? dt(this).weekNumber : NaN } get weekday() { return this.isValid ? dt(this).weekday : NaN } get isWeekend() { return this.isValid && this.loc.getWeekendDays().includes(this.weekday) } get localWeekday() { return this.isValid ? ht(this).weekday : NaN } get localWeekNumber() { return this.isValid ? ht(this).weekNumber : NaN } get localWeekYear() { return this.isValid ? ht(this).weekYear : NaN } get ordinal() { return this.isValid ? lt(this.c).ordinal : NaN } get monthShort() { return this.isValid ? Ne.months("short", { locObj: this.loc })[this.month - 1] : null } get monthLong() { return this.isValid ? Ne.months("long", { locObj: this.loc })[this.month - 1] : null } get weekdayShort() { return this.isValid ? Ne.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null } get weekdayLong() { return this.isValid ? Ne.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null } get offset() { return this.isValid ? +this.o : NaN } get offsetNameShort() { return this.isValid ? this.zone.offsetName(this.ts, { format: "short", locale: this.locale }) : null } get offsetNameLong() { return this.isValid ? this.zone.offsetName(this.ts, { format: "long", locale: this.locale }) : null } get isOffsetFixed() { return this.isValid ? this.zone.isUniversal : null } get isInDST() { return this.isOffsetFixed ? !1 : this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset } getPossibleOffsets() { if (!this.isValid || this.isOffsetFixed) return [this]; const e = 864e5, t = 6e4, r = Xe(this.c), s = this.zone.offset(r - e), i = this.zone.offset(r + e), a = this.zone.offset(r - s * t), o = this.zone.offset(r - i * t); if (a === o) return [this]; const u = r - a * t, l = r - o * t, h = ze(u, a), p = ze(l, o); return h.hour === p.hour && h.minute === p.minute && h.second === p.second && h.millisecond === p.millisecond ? [re(this, { ts: u }), re(this, { ts: l })] : [this] } get isInLeapYear() { return We(this.year) } get daysInMonth() { return Be(this.year, this.month) } get daysInYear() { return this.isValid ? ge(this.year) : NaN } get weeksInWeekYear() { return this.isValid ? xe(this.weekYear) : NaN } get weeksInLocalWeekYear() { return this.isValid ? xe(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN } resolvedLocaleOptions(e = {}) { const { locale: t, numberingSystem: r, calendar: s } = W.create(this.loc.clone(e), e).resolvedOptions(this); return { locale: t, numberingSystem: r, outputCalendar: s } } toUTC(e = 0, t = {}) { return this.setZone(C.instance(e), t) } toLocal() { return this.setZone(N.defaultZone) } setZone(e, { keepLocalTime: t = !1, keepCalendarTime: r = !1 } = {}) { if (e = X(e, N.defaultZone), e.equals(this.zone)) return this; if (e.isValid) { let s = this.ts; if (t || r) { const i = e.offset(this.ts), a = this.toObject();[s] = He(a, i, e) } return re(this, { ts: s, zone: e }) } else return w.invalid(Fe(e)) } reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) { const s = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r }); return re(this, { loc: s }) } setLocale(e) { return this.reconfigure({ locale: e }) } set(e) { if (!this.isValid) return this; const t = je(e, ln), { minDaysInFirstWeek: r, startOfWeek: s } = Bt(t, this.loc), i = !k(t.weekYear) || !k(t.weekNumber) || !k(t.weekday), a = !k(t.ordinal), o = !k(t.year), u = !k(t.month) || !k(t.day), l = o || u, h = t.weekYear || t.weekNumber; if ((l || a) && h) throw new ye("Can't mix weekYear/weekNumber units with year/month/day or ordinals"); if (u && a) throw new ye("Can't mix ordinal dates with month/day"); let p; i ? p = Gt({ ...Je(this.c, r, s), ...t }, r, s) : k(t.ordinal) ? (p = { ...this.toObject(), ...t }, k(t.day) && (p.day = Math.min(Be(p.year, p.month), p.day))) : p = Jt({ ...lt(this.c), ...t }); const [E, g] = He(p, this.o, this.zone); return re(this, { ts: E, o: g }) } plus(e) { if (!this.isValid) return this; const t = I.fromDurationLike(e); return re(this, on(this, t)) } minus(e) { if (!this.isValid) return this; const t = I.fromDurationLike(e).negate(); return re(this, on(this, t)) } startOf(e, { useLocaleWeeks: t = !1 } = {}) { if (!this.isValid) return this; const r = {}, s = I.normalizeUnit(e); switch (s) { case "years": r.month = 1; case "quarters": case "months": r.day = 1; case "weeks": case "days": r.hour = 0; case "hours": r.minute = 0; case "minutes": r.second = 0; case "seconds": r.millisecond = 0; break }if (s === "weeks") if (t) { const i = this.loc.getStartOfWeek(), { weekday: a } = this; a < i && (r.weekNumber = this.weekNumber - 1), r.weekday = i } else r.weekday = 1; if (s === "quarters") { const i = Math.ceil(this.month / 3); r.month = (i - 1) * 3 + 1 } return this.set(r) } endOf(e, t) { return this.isValid ? this.plus({ [e]: 1 }).startOf(e, t).minus(1) : this } toFormat(e, t = {}) { return this.isValid ? W.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : ft } toLocaleString(e = Ge, t = {}) { return this.isValid ? W.create(this.loc.clone(t), e).formatDateTime(this) : ft } toLocaleParts(e = {}) { return this.isValid ? W.create(this.loc.clone(e), e).formatDateTimeParts(this) : [] } toISO({ format: e = "extended", suppressSeconds: t = !1, suppressMilliseconds: r = !1, includeOffset: s = !0, extendedZone: i = !1 } = {}) { if (!this.isValid) return null; const a = e === "extended"; let o = mt(this, a); return o += "T", o += un(this, a, t, r, s, i), o } toISODate({ format: e = "extended" } = {}) { return this.isValid ? mt(this, e === "extended") : null } toISOWeekDate() { return Ue(this, "kkkk-'W'WW-c") } toISOTime({ suppressMilliseconds: e = !1, suppressSeconds: t = !1, includeOffset: r = !0, includePrefix: s = !1, extendedZone: i = !1, format: a = "extended" } = {}) { return this.isValid ? (s ? "T" : "") + un(this, a === "extended", t, e, r, i) : null } toRFC2822() { return Ue(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", !1) } toHTTP() { return Ue(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'") } toSQLDate() { return this.isValid ? mt(this, !0) : null } toSQLTime({ includeOffset: e = !0, includeZone: t = !1, includeOffsetSpace: r = !0 } = {}) { let s = "HH:mm:ss.SSS"; return (t || e) && (r && (s += " "), t ? s += "z" : e && (s += "ZZ")), Ue(this, s, !0) } toSQL(e = {}) { return this.isValid ? `${this.toSQLDate()} ${this.toSQLTime(e)}` : null } toString() { return this.isValid ? this.toISO() : ft } [Symbol.for("nodejs.util.inspect.custom")]() { return this.isValid ? `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }` : `DateTime { Invalid, reason: ${this.invalidReason} }` } valueOf() { return this.toMillis() } toMillis() { return this.isValid ? this.ts : NaN } toSeconds() { return this.isValid ? this.ts / 1e3 : NaN } toUnixInteger() { return this.isValid ? Math.floor(this.ts / 1e3) : NaN } toJSON() { return this.toISO() } toBSON() { return this.toJSDate() } toObject(e = {}) { if (!this.isValid) return {}; const t = { ...this.c }; return e.includeConfig && (t.outputCalendar = this.outputCalendar, t.numberingSystem = this.loc.numberingSystem, t.locale = this.loc.locale), t } toJSDate() { return new Date(this.isValid ? this.ts : NaN) } diff(e, t = "milliseconds", r = {}) { if (!this.isValid || !e.isValid) return I.invalid("created by diffing an invalid DateTime"); const s = { locale: this.locale, numberingSystem: this.numberingSystem, ...r }, i = ts(t).map(I.normalizeUnit), a = e.valueOf() > this.valueOf(), o = a ? this : e, u = a ? e : this, l = ii(o, u, i, s); return a ? l.negate() : l } diffNow(e = "milliseconds", t = {}) { return this.diff(w.now(), e, t) } until(e) { return this.isValid ? M.fromDateTimes(this, e) : this } hasSame(e, t, r) { if (!this.isValid) return !1; const s = e.valueOf(), i = this.setZone(e.zone, { keepLocalTime: !0 }); return i.startOf(t, r) <= s && s <= i.endOf(t, r) } equals(e) { return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc) } toRelative(e = {}) { if (!this.isValid) return null; const t = e.base || w.fromObject({}, { zone: this.zone }), r = e.padding ? this < t ? -e.padding : e.padding : 0; let s = ["years", "months", "days", "hours", "minutes", "seconds"], i = e.unit; return Array.isArray(e.unit) && (s = e.unit, i = void 0), fn(t, this.plus(r), { ...e, numeric: "always", units: s, unit: i }) } toRelativeCalendar(e = {}) { return this.isValid ? fn(e.base || w.fromObject({}, { zone: this.zone }), this, { ...e, numeric: "auto", units: ["years", "months", "days"], calendary: !0 }) : null } static min(...e) { if (!e.every(w.isDateTime)) throw new V("min requires all arguments be DateTimes"); return jt(e, t => t.valueOf(), Math.min) } static max(...e) { if (!e.every(w.isDateTime)) throw new V("max requires all arguments be DateTimes"); return jt(e, t => t.valueOf(), Math.max) } static fromFormatExplain(e, t, r = {}) { const { locale: s = null, numberingSystem: i = null } = r, a = D.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 }); return fr(a, e, t) } static fromStringExplain(e, t, r = {}) { return w.fromFormatExplain(e, t, r) } static buildFormatParser(e, t = {}) { const { locale: r = null, numberingSystem: s = null } = t, i = D.fromOpts({ locale: r, numberingSystem: s, defaultToEN: !0 }); return new cr(i, e) } static fromFormatParser(e, t, r = {}) { if (k(e) || k(t)) throw new V("fromFormatParser requires an input string and a format parser"); const { locale: s = null, numberingSystem: i = null } = r, a = D.fromOpts({ locale: s, numberingSystem: i, defaultToEN: !0 }); if (!a.equals(t.locale)) throw new V(`fromFormatParser called with a locale of ${a}, but the format parser was created for ${t.locale}`); const { result: o, zone: u, specificOffset: l, invalidReason: h } = t.explainFromTokens(e); return h ? w.invalid(h) : fe(o, u, r, `format ${t.format}`, e, l) } static get DATE_SHORT() { return Ge } static get DATE_MED() { return gn } static get DATE_MED_WITH_WEEKDAY() { return Nr } static get DATE_FULL() { return wn } static get DATE_HUGE() { return kn } static get TIME_SIMPLE() { return pn } static get TIME_WITH_SECONDS() { return Sn } static get TIME_WITH_SHORT_OFFSET() { return Tn } static get TIME_WITH_LONG_OFFSET() { return On } static get TIME_24_SIMPLE() { return In } static get TIME_24_WITH_SECONDS() { return vn } static get TIME_24_WITH_SHORT_OFFSET() { return Dn } static get TIME_24_WITH_LONG_OFFSET() { return En } static get DATETIME_SHORT() { return Mn } static get DATETIME_SHORT_WITH_SECONDS() { return Nn } static get DATETIME_MED() { return Fn } static get DATETIME_MED_WITH_SECONDS() { return bn } static get DATETIME_MED_WITH_WEEKDAY() { return Fr } static get DATETIME_FULL() { return xn } static get DATETIME_FULL_WITH_SECONDS() { return Vn } static get DATETIME_HUGE() { return Wn } static get DATETIME_HUGE_WITH_SECONDS() { return Cn } } function Ee(n) { if (w.isDateTime(n)) return n; if (n && n.valueOf && ee(n.valueOf())) return w.fromJSDate(n); if (n && typeof n == "object") return w.fromObject(n); throw new V(`Unknown datetime argument: ${n}, of type ${typeof n}`) } const Di = "3.5.0"; L.DateTime = w; L.Duration = I; L.FixedOffsetZone = C; L.IANAZone = G; L.Info = Ne; L.Interval = M; L.InvalidZone = $n; L.Settings = N; L.SystemZone = Ve; L.VERSION = Di; L.Zone = Te; var gr = {}; (function (n) { Object.defineProperty(n, "__esModule", { value: !0 }), n.parse = n.FIELD_INFO = void 0; const e = "l", t = "w", r = "lw", s = "?", i = "#", a = "*", o = "-", u = "/", l = { "@yearly": "0 0 1 1 ?", "@monthly": "0 0 1 * ?", "@weekly": "0 0 ? * 0", "@daily": "0 0 * * ?", "@hourly": "0 * * * ?" }; n.FIELD_INFO = { second: { min: 0, max: 59 }, minute: { min: 0, max: 59 }, hour: { min: 0, max: 23 }, day_of_month: { min: 1, max: 31 }, month: { min: 1, max: 12, alias: { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 } }, day_of_week: { min: 0, max: 7, alias: { 7: 0, sun: 0, mon: 1, tue: 2, wed: 3, thu: 4, fri: 5, sat: 6 } }, year: { min: 1970, max: 2099 } }; const h = ["second", "minute", "hour", "day_of_month", "month", "day_of_week", "year"]; function p(d) { return d && d.toString() === "true" } function E(d, c = m => m) { const m = new Set, S = []; return d.forEach(y => { const T = c(y); m.has(T) || (m.add(T), S.push(y)) }), S } function g(d, c) { return E(d.split(c).map(m => m.trim()).filter(m => m)) } function O(d, c) { return new Error(`Invalid cron expression [${d}]. ${c}`) } function J(d, c, m) { if (m = m.toLowerCase().trim(), m === a) return { all: !0 }; if (m === s) return B(d, c, m); const S = g(m, ","), y = {}; for (const T of S) T && (T.indexOf(u) >= 0 ? (y.steps = y.steps || [], y.steps.push(nt(d, c, T))) : T.indexOf(o) >= 0 ? (y.ranges = y.ranges || [], y.ranges.push(it(d, c, T))) : T.indexOf(i) >= 0 ? (y.nthDays = y.nthDays || [], y.nthDays.push(Le(d, c, T))) : T === e ? y.lastDay = A(d, c, T) : T === r ? y.lastWeekday = te(d, c, T) : c === "day_of_month" && T.indexOf(t) >= 0 ? (y.nearestWeekdays = y.nearestWeekdays || [], y.nearestWeekdays.push(rt(d, c, T))) : c === "day_of_week" && T.endsWith(e) ? (y.lastDays = y.lastDays || [], y.lastDays.push(st(d, c, T))) : (y.values = y.values || [], y.values.push(_e(d, c, T)))); return y.values && (y.values = E(y.values)), y } function A(d, c, m) { if (c === "day_of_week" || c === "day_of_month") return !0; throw O(d, `Invalid value for [${m}] for field [${c}]. It can be used only for [day_of_month or day_of_week] fields.`) } function B(d, c, m) { if (c === "day_of_week" || c === "day_of_month") return { omit: !0 }; throw O(d, `Invalid Value [${m}] for field [${c}]. It can be specified only for [day_of_month or day_of_week] fields.`) } function te(d, c, m) { if (c === "day_of_month") return !0; throw O(d, `Invalid value for [${m}] for field [${c}]. It can be used only for [day_of_month] fields.`) } function _e(d, c, m) { const S = x(d, c, m), y = n.FIELD_INFO[c]; if (S < y.min) throw O(d, `Value [${m}] out of range for field [${c}]. It must be greater than or equals to [${y.min}].`); if (y.max && S > y.max) throw O(d, `Value [${m}] out of range for field [${c}]. It must be less than or equals to [${y.max}].`); return S } function nt(d, c, m) { const S = m.split(u); if (S.length != 2) throw O(d, `Invalid step range [${m}] for field [${c}]. Expected exactly 2 values separated by a / but got [${S.length}] values.`); const y = n.FIELD_INFO[c], T = S[0].indexOf(o) >= 0 ? S[0].split(o) : [S[0]], b = T[0] === a ? y.min : x(d, c, Z(c, T[0])), oe = T.length > 1 ? x(d, c, Z(c, T[1])) : y.max, ue = x(d, c, Z(c, S[1])); if (b < y.min) throw O(d, `Invalid step range [${m}] for field [${c}]. From value [${b}] out of range. It must be greater than or equals to [${y.min}]`); if (oe > y.max) throw O(d, `Invalid step range [${m}] for field [${c}]. To value [${oe}] out of range. It must be less than or equals to [${y.max}]`); if (ue > y.max) throw O(d, `Invalid step range [${m}] for field [${c}]. Step value [${m}] out of range. It must be less than or equals to [${y.max}]`); return { from: b, to: oe, step: ue } } function Le(d, c, m) { if (c !== "day_of_week") throw O(d, `Invalid value [${m}] for field [${c}]. Nth day can be used only in [day_of_week] field.`); const S = m.split(i); if (S.length !== 2) throw O(d, `Invalid nth day value [${m}] for field [${c}]. It must be in [day_of_week#instance] format.`); const y = x(d, c, S[0]), T = x(d, void 0, S[1]); if (T < 1 || T > 5) throw O(d, `Invalid Day of Week instance value [${T}] for field [${c}]. It must be between 1 and 5.`); return { day_of_week: y, instance: T } } function rt(d, c, m) { if (c !== "day_of_month") throw O(d, `Invalid value [${m}] for field [${c}]. Nearest weekday can be used only in [day_of_month] field.`); return x(d, c, m.split(t)[0]) } function st(d, c, m) { return x(d, c, m.split(e)[0]) } function it(d, c, m) { const S = m.split(o); if (S.length != 2) throw O(d, `Invalid range [${m}] for field [${c}]. Range should have two values separated by a - but got [${S.length}] values.`); const y = x(d, c, Z(c, S[0])); let T = x(d, c, Z(c, S[1])); if (c == "day_of_week" && T === 0 && (T = 7), y >= T) throw O(d, `Invalid range [${m}] for field [${c}]. From value must be less than to value.`); const b = n.FIELD_INFO[c]; if (y < b.min || T > b.max) throw O(d, `Invalid range [${m}] for field [${c}]. From or to value is out of allowed min/max values. Allowed values are between [${b.min}-${b.max}].`); return { from: y, to: T } } function x(d, c, m) { const S = parseInt(Z(c, m), 10); if (Number.isNaN(S)) throw O(d, `Invalid numeric value [${m}] in field [${c}].`); return S } function Z(d, c) { if (!d) return c; const S = (n.FIELD_INFO[d].alias || {})[c]; return S === void 0 ? c : S.toString() } function at(d, c) { if (!d) throw new Error("Cron expression cannot be blank"); let m = d, S = c.hasSeconds; l[m] && (m = l[d], S = !1); const y = S ? 5 : 4, T = S ? 7 : 6, b = m.split(/\s+/).map($ => $.trim()).filter($ => $); if (b.length < y || b.length > T) throw new Error(`Invalid cron expression [${d}]. Expected [${y} to ${T}] fields but found [${b.length}] fields.`); S || b.unshift("0"), b.length === 5 && b.push(s), b.length === 6 && b.push(a); const oe = {}; for (let $ = 0; $ < h.length; $++)oe[h[$]] = b[$]; const ue = {}; for (const $ of h) $ === "second" && !S ? ue[$] = { omit: !0 } : ue[$] = J(d, $, oe[$]); return ue } function vr(d, c = {}) { if (!d) throw new Error("Cron expression cannot be blank"); return c.hasSeconds = p(c.hasSeconds), { pattern: d, expressions: g(d, "|").map(S => at(S, c)) } } n.parse = vr })(gr); Object.defineProperty(pe, "__esModule", { value: !0 }); pe.isTimeMatches = pe.getFutureMatches = void 0; const Ot = L, Qe = gr, Ei = 1e5, Mi = 0, wr = 1, It = 5, kr = 6, Vt = "Etc/UTC", Ni = ["second", "minute", "hour", "day_of_month", "month", "year", "day_of_week"], pr = Ni.reverse(), Fi = ["second", "minute", "hour", "month", "year"], bi = Fi.reverse(); function Wt(n) { if (!n) return n; let e; const t = Array.isArray(n) ? [] : {}; for (const r in n) e = n[r], t[r] = typeof e == "object" ? Wt(e) : e; return t } function Sr(n, e = t => t) { const t = new Set, r = []; return n.forEach(s => { const i = e(s); t.has(i) || (t.add(i), r.push(s)) }), r } function Tr(n) { return n.sort((e, t) => e - t), n } function ie(n) { const e = n.weekday; return e === 7 ? 0 : e } function me(n, e, t) { const r = []; if (t == 0) r.push(n); else for (let s = n; s <= e; s += t)r.push(s); return r } function ke(n) { return !n || n.length === 0 } function yt(n, e, t) { const r = []; return n.expressions.forEach(s => { r.push(...xi(s, e, t)) }), r.length === 0 ? r : Tr(Sr(r)) } function xi(n, e, t) { const r = n[e]; if (r.omit) return e === "second" ? [0] : []; if (e === "day_of_week") { const o = Qe.FIELD_INFO.day_of_month; return me(o.min, o.max, 1) } const s = Qe.FIELD_INFO[e], i = r.all || r.lastDay || r.lastWeekday || !ke(r.lastDays) || !ke(r.nearestWeekdays) || !ke(r.nthDays), a = [...r.values || []]; if (i) { const o = e == "year" ? t : s.min; return a.push(...me(o, s.max, 1)), a } return r.ranges && r.ranges.forEach(o => { a.push(...me(o.from, o.to, 1)) }), r.steps && r.steps.forEach(o => { a.push(...me(o.from, o.to, o.step)) }), r.steps && r.steps.forEach(o => { a.push(...me(o.from, o.to, o.step)) }), a } function Vi(n, e) { const t = {}; for (const r of pr) r === "day_of_week" || r === "day_of_month" || (t[r] = { values: yt(n, r, e) }); return t.day_of_month = { values: Tr(Sr([...yt(n, "day_of_month", e), ...yt(n, "day_of_week", e)])) }, t } function Wi(n, e) { const t = n[e]; t.steps && (t.values = t.values || [], t.steps.forEach(r => { t.values.push(...me(r.from, r.to, r.step)) }), delete t.steps) } function Or(n) { for (const e of n.expressions) { !e.day_of_month.omit && !e.day_of_week.omit && (!e.day_of_month.all && e.day_of_week.all && (delete e.day_of_week.all, e.day_of_week.omit = !0), e.day_of_month.all && !e.day_of_week.all && !e.day_of_week.omit && (delete e.day_of_month.all, e.day_of_month.omit = !0)); for (const t of pr) Wi(e, t) } return n } function de(n, e) { return n.set(e) } function* Ci(n, e) { const t = Vi(n, e.year), r = e.toMillis(); let s = e, i = !1; for (const a of t.year.values) if (!(a < e.year)) { s = de(s, { year: a }); for (const o of t.month.values) if (!(a === e.year && o < e.month)) { s = de(s, { month: o }); for (const u of t.day_of_month.values) if (!(a === e.year && o === e.month && u < e.day) && !(u > s.daysInMonth)) { s = de(s, { day: u }); for (const l of t.hour.values) if (!(a === e.year && o === e.month && u === e.day && l < e.hour)) { s = de(s, { hour: l }); for (const h of t.minute.values) { s = de(s, { minute: h }); for (const p of t.second.values) s = de(s, { second: p }), i || s.toMillis() >= r && (i = !0), i && (yield s) } } } } } } function Ct(n, e) { let t = n.endOf("month"); const r = t.day; if (e === void 0) return r; for (; ie(t) !== e;)t = t.plus({ day: -1 }); return t.day } function $i(n) { const e = n.endOf("month"), t = ie(e); return t >= wr && t <= It ? e.day : Ct(n, It) } function _i(n, e) { const t = []; for (let r = 1; r < 31; r++) { const s = n.set({ day: r }); if (s.month != n.month) break; ie(s) === e && t.push(s.day) } return t } function Li(n) { const e = ie(n); return e >= wr && e <= It } function hn(n, e) { return ie(n) === e } function Ai(n, e) { return n.daysInMonth < e && (e = n.daysInMonth), n.set({ day: e }) } function Zi(n, e) { if (!Li(n)) return !1; const t = Ai(n, e); return n.day === t.day ? !0 : hn(t, kr) ? t.day === 1 ? n.day === 3 : t.day - 1 == n.day : hn(t, Mi) ? t.day === n.daysInMonth ? n.day === n.daysInMonth - 2 : t.day + 1 == n.day : !1 } function Ri(n, e, t) { return t >= n && t <= e } function $t(n, e, t) { const r = n[e]; return !r || r.all ? !0 : r.omit ? e === "second" : !!(r.values && r.values.includes(t) || r.ranges && r.ranges.find(s => Ri(s.from, s.to, t))) } function zi(n, e, t) { const r = n[e]; return r.omit ? !1 : r.lastWeekday && t.day === $i(t) || r.lastDay && t.day === Ct(t) || !ke(r.nearestWeekdays) && r.nearestWeekdays.find(s => Zi(t, s)) !== void 0 ? !0 : $t(n, e, t.day) } function Ui(n, e, t) { const r = n[e]; return r.omit ? !1 : r.lastDay && ie(t) === kr || !ke(r.lastDays) && r.lastDays.find(s => t.day === Ct(t, s)) !== void 0 || !ke(r.nthDays) && r.nthDays.find(s => { const i = _i(t, s.day_of_week); return i.length >= s.instance && i[s.instance - 1] === t.day }) !== void 0 ? !0 : $t(n, e, ie(t)) } function qi(n, e) { for (const t of bi) if (!$t(n, t, e[t])) return !1; return zi(n, "day_of_month", e) || Ui(n, "day_of_week", e) } function Ir(n, e) { return n.expressions.find(t => qi(t, e)) !== void 0 } function Hi(n, e) { return e.formatInTimezone ? n.toISO({ suppressMilliseconds: !0 }) : `${n.setZone(Vt).toISO({ suppressMilliseconds: !0, includeOffset: !1 })}Z` } function Yi(n, e = {}) { const t = { zone: e.timezone || Vt }, r = Ot.DateTime.fromISO(e.startAt ? e.startAt : new Date().toISOString(), t).set({ millisecond: 0 }), s = e.endAt ? Ot.DateTime.fromISO(e.endAt, t) : void 0, i = e.matchCount || 5, a = [], o = Or(typeof n == "string" ? (0, Qe.parse)(n, e) : Wt(n)), u = Ci(o, r), l = e.maxLoopCount || Ei; let h = 0; for (; h < l;) { h++; const p = u.next().value; if (!p || s && p.toMillis() >= s.toMillis()) break; if (!(p.toMillis() < r.toMillis())) { if (Ir(o, p)) { const E = Hi(p, e); (e.matchValidator ? e.matchValidator(E) : !0) && a.push(E) } if (a.length >= i) break } } return a } pe.getFutureMatches = Yi; function Pi(n, e, t) { const r = Or(typeof n == "string" ? (0, Qe.parse)(n) : Wt(n)), s = Ot.DateTime.fromISO(e, { zone: t || Vt }); return Ir(r, s) } pe.isTimeMatches = Pi; (function (n) { Object.defineProperty(n, "__esModule", { value: !0 }), n.isTimeMatches = n.getFutureMatches = void 0; var e = pe; Object.defineProperty(n, "getFutureMatches", { enumerable: !0, get: function () { return e.getFutureMatches } }), Object.defineProperty(n, "isTimeMatches", { enumerable: !0, get: function () { return e.isTimeMatches } }) })(mn);
// https://github.com/datasert/cronjs

function getTodayCronTimes(n) {
    let times = n.split('\n').map(nn => _getTodayCronTimes(nn))
    return times.flat().sort();
}

function _getTodayCronTimes(n) {
    try {
        let now = new Date();
        let timeBegin = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 5, 0, 0);
        let timeEnd = new Date(now.getFullYear() + 1, now.getMonth(), now.getDate(), 4, 59, 59);
        const e = mn.getFutureMatches(n, {
            timezone: "Asia/Shanghai",
            startAt: timeBegin.toISOString(),
            matchCount: 5,
            endAt: timeEnd.toISOString(),
            formatInTimezone: !0,
        });
        return e.map(d => new Date(d).getTime() / 1000)
    } catch (error) {
        console.error("cron表达式错误：" + n, error)
        throw error;
    }

}
console.log("7 8 * * *", getTodayCronTimes("7 8 * * *\n30 11 * * *"));
